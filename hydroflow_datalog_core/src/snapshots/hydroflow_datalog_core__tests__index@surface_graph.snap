---
source: hydroflow_datalog_core/src/lib.rs
expression: flat_graph_ref.surface_syntax_string()
---
2v1 = unique :: < 'tick > ();
3v1 = tee ();
5v1 = unique :: < 'tick > ();
8v1 = unique :: < 'tick > ();
11v1 = unique :: < 'tick > ();
14v1 = unique :: < 'tick > ();
17v1 = unique :: < 'tick > ();
18v1 = difference :: < 'tick , 'static > ();
19v1 = tee ();
20v1 = next_tick ();
22v1 = unique :: < 'tick > ();
23v1 = difference :: < 'tick , 'static > ();
24v1 = tee ();
25v1 = next_tick ();
26v1 = source_stream (ints);
27v1 = for_each (| v | result . send (v) . unwrap ());
28v1 = for_each (| v | result2 . send (v) . unwrap ());
29v1 = for_each (| v | result3 . send (v) . unwrap ());
30v1 = for_each (| v | result4 . send (v) . unwrap ());
31v1 = persist ();
32v1 = for_each (| v | result5 . send (v) . unwrap ());
33v1 = map (| row : (_ , _ ,) | ((row . 0 , row . 1 ,) , ()));
34v1 = enumerate :: < 'tick > ();
35v1 = map (| (i , (g , a)) : (_ , ((_ , _ ,) , _)) | (g . 0 , g . 1 , i ,));
36v1 = map (| row : (_ , _ ,) | ((row . 0 ,) , ((row . 1) ,)));
37v1 = group_by :: < 'tick , (_ ,) , (Option < _ > ,) > (| | (None ,) , | old : & mut (Option < _ > ,) , val : (_ ,) | { old . 0 = if let Some (prev) = old . 0 . take () { Some ({ let prev : (hydroflow :: rustc_hash :: FxHashSet < _ > , _) = prev ; let mut set : hydroflow :: rustc_hash :: FxHashSet < _ > = prev . 0 ; if set . insert (val . 0) { (set , prev . 1 + 1) } else { (set , prev . 1) } }) } else { Some ({ let mut set = hydroflow :: rustc_hash :: FxHashSet :: < _ > :: default () ; set . insert (val . 0) ; (set , 1) }) } ; });
38v1 = enumerate :: < 'tick > ();
39v1 = map (| (i , (g , a)) : (_ , ((_ ,) , _)) | (g . 0 , a . 0 . unwrap () . 1 , i ,));
40v1 = map (| row : (_ , _ ,) | ((row . 0 , row . 1 ,) , ()));
41v1 = map (| (g , a) : ((_ , _ ,) , _) | (g . 0 , g . 1 ,));
42v1 = map (| row : (_ , _ ,) | ((row . 0 , row . 1 ,) , ()));
43v1 = enumerate :: < 'static > ();
44v1 = map (| (i , (g , a)) : (_ , ((_ , _ ,) , _)) | (g . 0 , g . 1 , i ,));
45v1 = persist ();
46v1 = map (| row : (_ , _ ,) | ((row . 0 ,) , ((row . 1) ,)));
47v1 = group_by :: < 'static , (_ ,) , (Option < _ > ,) > (| | (None ,) , | old : & mut (Option < _ > ,) , val : (_ ,) | { old . 0 = if let Some (prev) = old . 0 . take () { Some ({ let prev : (hydroflow :: rustc_hash :: FxHashSet < _ > , _) = prev ; let mut set : hydroflow :: rustc_hash :: FxHashSet < _ > = prev . 0 ; if set . insert (val . 0) { (set , prev . 1 + 1) } else { (set , prev . 1) } }) } else { Some ({ let mut set = hydroflow :: rustc_hash :: FxHashSet :: < _ > :: default () ; set . insert (val . 0) ; (set , 1) }) } ; });
48v1 = enumerate :: < 'tick > ();
49v1 = map (| (i , (g , a)) : (_ , ((_ ,) , _)) | (g . 0 , a . 0 . unwrap () . 1 , i ,));
50v1 = map (| row : (_ , _ ,) | ((row . 0 , row . 1 ,) , ()));
51v1 = enumerate :: < 'static > ();
52v1 = map (| (i , (g , a)) : (_ , ((_ , _ ,) , _)) | (g . 0 , g . 1 , i ,));

26v1 -> 2v1;
2v1 -> 3v1;
35v1 -> 5v1;
39v1 -> 8v1;
45v1 -> 11v1;
49v1 -> 14v1;
52v1 -> 17v1;
18v1 -> 19v1;
17v1 -> 18v1;
20v1 -> 18v1;
19v1 -> 20v1;
41v1 -> 22v1;
23v1 -> 24v1;
22v1 -> 23v1;
25v1 -> 23v1;
24v1 -> 25v1;
5v1 -> 27v1;
8v1 -> 28v1;
11v1 -> 29v1;
14v1 -> 30v1;
31v1 -> 32v1;
19v1 -> 31v1;
34v1 -> 35v1;
33v1 -> 34v1;
3v1 -> 33v1;
38v1 -> 39v1;
37v1 -> 38v1;
36v1 -> 37v1;
3v1 -> 36v1;
40v1 -> 41v1;
3v1 -> 40v1;
44v1 -> 45v1;
43v1 -> 44v1;
42v1 -> 43v1;
24v1 -> 42v1;
48v1 -> 49v1;
47v1 -> 48v1;
46v1 -> 47v1;
24v1 -> 46v1;
51v1 -> 52v1;
50v1 -> 51v1;
24v1 -> 50v1;

