<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Hydroflow Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">1.</strong> Quickstart</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="example_1_surface.html"><strong aria-hidden="true">1.2.</strong> Simplest Example</a></li><li class="chapter-item expanded "><a href="example_2_surface.html"><strong aria-hidden="true">1.3.</strong> Simple Example</a></li><li class="chapter-item expanded "><a href="example_3_surface.html"><strong aria-hidden="true">1.4.</strong> A Example With Streaming Input</a></li><li class="chapter-item expanded "><a href="example_4_surface.html"><strong aria-hidden="true">1.5.</strong> Graph Neighbors</a></li><li class="chapter-item expanded "><a href="example_4_1_surface.html"><strong aria-hidden="true">1.6.</strong> Graph Reachability</a></li><li class="chapter-item expanded "><a href="example_5_surface.html"><strong aria-hidden="true">1.7.</strong> Graph Un-Reachability</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">2.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="surface_syntax.html"><strong aria-hidden="true">3.</strong> Syntax</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="surface_embedding.html"><strong aria-hidden="true">3.1.</strong> Rust Embedding</a></li><li class="chapter-item expanded "><a href="surface_flows.html"><strong aria-hidden="true">3.2.</strong> Flows</a></li><li class="chapter-item expanded "><a href="surface_data.html"><strong aria-hidden="true">3.3.</strong> Data Sources</a></li><li class="chapter-item expanded "><a href="surface_ops.gen.html"><strong aria-hidden="true">3.4.</strong> Operators</a></li></ol></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">4.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="in-out_trees.html"><strong aria-hidden="true">4.1.</strong> Subgraph In-Out Trees</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hydroflow Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/hydro-project/hydroflow">Hydroflow</a> is a dataflow runtime
written in Rust, serving as the execution layer of the <a href="https://hydro-project.github.io/">Hydro stack</a>.
This book teaches how to set up and get started with Hydroflow.</p>
<p>Keep in mind that Hydroflow is under active development and is constantly
changing. However this book is tested in CI so should always be up-to-date
(though incomplete, for now).</p>
<p>If you have any questions, feel free to <a href="https://github.com/hydro-project/hydroflow/issues/new">create an issue on Github</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>This section will get you up and running with Rust and Hydroflow without
worrying too much about the tricky details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>This section explains how to get Hydroflow running, either for development or
usage, even if you are not familiar with Rust development.</p>
<h2 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h2>
<p>First you will need to install Rust. We recommend the conventional installation
method, <code>rustup</code>, which allows you to easily manage and update Rust versions.</p>
<p><a href="https://www.rust-lang.org/tools/install"><strong>Install Rust</strong></a></p>
<p>This will install <code>rustup</code> and the Rust package manager <code>cargo</code> (and the
internally-used <code>rustc</code> compiler). <code>cargo</code> is Rust's main development tool,
used for building, running, and testing Rust code.</p>
<p>The following <code>cargo</code> commands will come in handy:</p>
<ul>
<li><code>cargo check --all-targets</code> - Checks the workspace for any compile-time
errors.</li>
<li><code>cargo build --all-targets</code> - Builds all projects/tests/benchmarks/examples
in the workspace.</li>
<li><code>cargo clean</code> - Cleans the build cache, sometimes needed if the build is
acting up.</li>
<li><code>cargo test</code> - Runs tests in the workspace.</li>
<li><code>cargo run -p hydroflow --example &lt;example name&gt;</code> - Run an example program in
<code>hydroflow/examples</code>.</li>
</ul>
<p>To learn Rust see the official <a href="https://www.rust-lang.org/learn">Learn Rust page</a>.
Here are some good resources:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/"><em>The Rust Programming Language</em>, AKA &quot;The Book&quot;</a></li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/">Learn Rust With Entirely Too Many Linked Lists</a>
is a good way to learn Rust's ownership system and its
implications.</li>
</ul>
<h2 id="vs-code-setup"><a class="header" href="#vs-code-setup">VS Code Setup</a></h2>
<p>We recommend using VS Code with the <code>rust-anaylzer</code> extension (and NOT the
<code>Rust</code> extension). To enable the pre-release version of <code>rust-analyzer</code>
(required by some new nightly syntax we use, at least until 2022-03-14), click
the &quot;Switch to Pre-Release Version&quot; button next to the uninstall button.</p>
<h2 id="hydroflow-setup"><a class="header" href="#hydroflow-setup">Hydroflow Setup</a></h2>
<p>The easiest way to get started with Hydroflow is to clone and work in the
repository directly. You should fork the repository if you want to push your
changes.</p>
<pre><code class="language-bash">git clone git@github.com:hydro-project/hydroflow.git
</code></pre>
<p>Hydroflow requires nightly Rust, but the repo is already configured for it via
<code>rust-toolchain.toml</code>.</p>
<p>We can then open the repo in VS Code or IDE of your choice. <code>rust-analyzer</code>
will provide inline type and error messages, code completion, etc.</p>
<h2 id="development"><a class="header" href="#development">Development</a></h2>
<p>The easiest way to try Hydroflow is with an &quot;example&quot;, found in the
<a href="https://github.com/hydro-project/hydroflow/tree/main/hydroflow/examples"><code>hydroflow/examples</code> folder</a>.
These examples are include via the <a href="https://github.com/hydro-project/hydroflow/blob/main/hydroflow/Cargo.toml"><code>hydroflow/Cargo.toml</code> file</a>,
so make sure to add your example there if you create a new one. The simplest
example is <a href="https://github.com/hydro-project/hydroflow/blob/main/hydroflow/examples/graph_reachability/main.rs"><code>graph_reachability</code></a>.</p>
<p>The Hydroflow repository is set up as a <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">workspace</a>,
i.e. a repo containing a bunch of separate packages, <code>hydroflow</code> is just the
main one. So if you want to work in a proper separate cargo package, you can
create one and add it into the <a href="https://github.com/hydro-project/hydroflow/blob/main/Cargo.toml">root <code>Cargo.toml</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simplest-example"><a class="header" href="#simplest-example">Simplest Example</a></h1>
<p>Lets start out with the simplest possible Hydroflow program, which prints out
the numbers in <code>0..10</code>.</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;

pub fn main() {
    let mut flow = hydroflow_syntax! {
        recv_iter(0..10) -&gt; for_each(|n| println!(&quot;Hello {}&quot;, n));
    };

    flow.run_available();
}
</code></pre></pre>
<p>And the output:</p>
<pre><code class="language-txt">Hello 0
Hello 1
Hello 2
Hello 3
Hello 4
Hello 5
Hello 6
Hello 7
Hello 8
Hello 9
</code></pre>
<p>Although this is a trivial program, it's useful to go through it line by line.</p>
<pre><code class="language-rust ignore">use hydroflow::hydroflow_syntax;
</code></pre>
<p>This import gives you everything you need from hydroflow to write code with the 
<a href="./surface_syntax.html"><em>surface syntax</em></a>, which is the most common way to interact
with Hydroflow.</p>
<p>Next, inside the main method we specify a flow by calling the 
<code>hydroflow_syntax!</code> macro. We assign the resulting <code>Hydroflow</code> instance to
a mutable variable---we will be changing its status when we run it.</p>
<pre><code class="language-rust ignore"><span class="boring">use hydroflow::hydroflow_syntax;
</span>pub fn main() {
    let mut flow = hydroflow_syntax! {
        recv_iter(0..10) -&gt; for_each(|n| println!(&quot;Hello {}&quot;, n));
    };
</code></pre>
<p>The flow starts with a <a href="./surface_ops.html#recv_iter"><code>recv_iter</code></a> operator that emits the 
numbers 1 through 10, and passes them along the arrow <code>-&gt;</code> operator downstream to a 
<a href="./surface_ops.html#for_each"><code>for_each</code></a> operator that invokes its closure argument to print each
item passed in.</p>
<p>Finally we run this flow via the <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run_available"><code>run_available()</code> method</a>.</p>
<pre><code class="language-rust ignore">    flow.run_available();
}
</code></pre>
<p>Note that <code>run_available()</code> runs the Hydroflow graph until no more work is immediately
available. In this case running the graph drains the iterator completely, so no
more work will ever be available. But once we add in external inputs such as
network ingress then more work might appear later. The <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run_epoch"><code>run_epoch()</code></a>,
<a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run_stratum"><code>run_stratum()</code></a>,
<a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run"><code>run()</code></a>,
and <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run_async"><code>run_async()</code></a>
methods provide other ways to execute the graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-example"><a class="header" href="#simple-example">Simple Example</a></h1>
<p>Lets build on the simplest example to explore some of the operators available
in Hydroflow. You may be familiar with operators such as <a href="./surface_ops.html#map"><code>map(...)</code></a>,
<a href="./surface_ops.html#filter"><code>filter(...)</code></a>, <a href="./surface_ops.html#flat_map"><code>flat_map</code>(...)</a>,
etc. from Rust iterators or from other programming languages, and these are
also available in Hydroflow.</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;

pub fn main() {
    let mut flow = hydroflow_syntax! {
        recv_iter(0..10)
            -&gt; map(|n| n * n)
            -&gt; filter(|&amp;n| n &gt; 10)
            -&gt; map(|n| (n..=n+1))
            -&gt; flat_map(|n| n)
            -&gt; for_each(|n| println!(&quot;Howdy {}&quot;, n));
    };

    flow.run_available();
}
</code></pre></pre>
<p><code>-&gt; map(|n| n * n)</code> transforms each element one-to-one as it flows through the subgraph.
In this case, we square each number. Then <code>-&gt; filter()</code> only keeps any squared
numbers which are greater than 10.</p>
<p>The next <code>-&gt; map(|n| (n..=n+1))</code> uses standard Rust syntax to convert each number <code>n</code> into a
<a href="https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html"><code>RangeInclusive</code></a>
from <code>n</code> to <code>n+1</code>. We then call <code>-&gt; flat_map()</code> to convert the ranges
into a stream of the individual numbers which they contain.</p>
<p>We can also express the same program with more aggressive use of combination operators like
<a href="./surface_ops.html#filtermap"><code>filter_map()</code></a> and <a href="./surface_ops.html#flatmap"><code>flat_map()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use hydroflow::hydroflow_syntax;
</span> pub fn main() {
    let mut flow = hydroflow_syntax! {
        recv_iter(0..10)
        -&gt; filter_map(|n| {
            let n2 = n * n;
            if n2 &gt; 10 {
                Some(n2)
            }
            else {
                None
            }
        })
        -&gt; flat_map(|n| (n..=n+1))
        -&gt; for_each(|n| println!(&quot;G'day {}&quot;, n))
    };

    flow.run_available();
}
</code></pre></pre>
<p>Results:</p>
<pre><code class="language-txt">G'day 16
G'day 17
G'day 25
G'day 26
G'day 36
G'day 37
G'day 49
G'day 50
G'day 64
G'day 65
G'day 81
G'day 82
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-example-with-streaming-input"><a class="header" href="#an-example-with-streaming-input">An Example With Streaming Input</a></h1>
<p>In this example we'll introduce the concept of handoffs and external inputs.</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;

pub fn main() {
    let mut hydroflow = hydroflow_syntax! {
        // code will go here
    };

    hydroflow.run_available();
}
</code></pre></pre>
<p>We'll start out with the above boilerplate. To add a new external input
channel, we can use the <code>hydroflow::util::unbounded_channel()</code> function:</p>
<pre><code class="language-rust  ignore">    let (input_example, example_recv) = hydroflow::util::unbounded_channel::&lt;usize&gt;();
</code></pre>
<p>This is a <a href="https://docs.rs/tokio/latest/tokio/sync/mpsc/fn.unbounded_channel.html">multiple-producer/single-consumer (<code>mpsc</code>) channel</a>, which is usually the appropriate choice for an inbound Hydroflow stream:
think of it as a high-performance &quot;mailbox&quot; that any sender can fill with well-typed data.</p>
<p>The Rust <code>::&lt;usize&gt;</code> syntax is affectionately
called the &quot;turbofish&quot; and is how type parameters (generic arguments) are
supplied to generic types and functions. In this case it specifies that this tokio channel
transmits <code>usize</code> items.
The returned <code>example_recv</code> value can be chained via a <a href="./surface_ops#example_recv"><code>recv_stream</code></a> 
to build a Hydroflow subgraph just like before. Here is the same program as before, but using the
input channel:</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;

pub fn main() {
// Create our channel input
let (input_example, example_recv) = hydroflow::util::unbounded_channel::&lt;usize&gt;();

let mut hydroflow = hydroflow_syntax! {
    recv_stream(example_recv)
    -&gt; filter_map(|n: usize| {
        let n2 = n * n;
        if n2 &gt; 10 {
            Some(n2)
        }
        else {
            None
        }
    })
    -&gt; flat_map(|n| (n..=n+1))
    -&gt; for_each(|n| println!(&quot;Ahoj {}&quot;, n))
};

println!(&quot;A&quot;);
input_example.send(0).unwrap();
input_example.send(1).unwrap();
input_example.send(2).unwrap();
input_example.send(3).unwrap();
input_example.send(4).unwrap();
input_example.send(5).unwrap();

hydroflow.run_available();

println!(&quot;B&quot;);
input_example.send(6).unwrap();
input_example.send(7).unwrap();
input_example.send(8).unwrap();
input_example.send(9).unwrap();

hydroflow.run_available();
}
</code></pre></pre>
<pre><code class="language-txt">A
Ahoj 16
Ahoj 17
Ahoj 25
Ahoj 26
B
Ahoj 36
Ahoj 37
Ahoj 49
Ahoj 50
Ahoj 64
Ahoj 65
Ahoj 81
Ahoj 82
</code></pre>
<p>At the bottom we can see supplying inputs with the tokio <code>.send()</code> method; we call Rust's <code>.unwrap()</code> 
method to ignore the error messages from <code>.send()</code> in this simple case. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-neighbors"><a class="header" href="#graph-neighbors">Graph Neighbors</a></h1>
<p>So far all the operators we've used have one input and one output and therefore
create a linear flow of operators. Let's now take a look at a Hydroflow program containing
an operator which has multiple inputs; in the following examples we'll extend this to
multiple outputs.</p>
<p>To motivate this, we'll build a simple flow-based algorithm for the problem of <em>graph neighbors</em>. 
Given an abstract graph -- represented as data in the form of a streaming list of edges -- which 
vertices can be reached from a vertex passed in as the <code>origin</code>? It turns out this is fairly 
naturally represented as a dataflow program. </p>
<blockquote>
<p><strong>Note on terminology</strong>: In each of the next few examples, we're going to write a Hydroflow program (a dataflow graph) to process data that itself represents some other graph! To avoid confusion, in these examples, we'll refer to the Hydroflow program as a &quot;flow&quot; or &quot;program&quot;, and the data as a &quot;graph&quot; of &quot;edges&quot; and &quot;vertices&quot;.</p>
</blockquote>
<p>To work our way up to graph reachability, we'll first start with a simple flow that finds
graph <em>neighbors</em>: nodes that are just one hop away. </p>
<p>Our first Hydroflow program will take
our initial <code>origin</code> vertex as one input, and join it another input that streams in all the edges---this 
join will stream out the vertices that are one hop (edge) away from the starting vertex. </p>
<p>Here is an <em>intuitive</em> diagram of that dataflow program (we'll see complete, autogenerated Hydroflow diagrams
below):</p>
<pre class="mermaid">graph TD
  subgraph simple version
    00[Origin Vertex]
    01[Stream of Edges]
    
    20(&quot;V ⨝ E&quot;)
    40[Output]

    00 --&gt; 20
    
    01 ---&gt; 20
    20 --&gt; 40
    
  end
</pre>
<p>Lets take a look at some hydroflow code that implements the program:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use hydroflow::hydroflow_syntax;
</span>pub fn main() {
    // An edge in the input data = a pair of `usize` vertex IDs.
    let (pairs_send, pairs_recv) = hydroflow::util::unbounded_channel::&lt;(usize, usize)&gt;();

    let mut flow = hydroflow_syntax! {
        // inputs: the origin vertex (node 0) and stream of input edges
        origin = recv_iter(vec![0]);
        stream_of_edges = recv_stream(pairs_recv);

        // the join
        my_join = join() -&gt; map(|(_x, (_y, z))| z);
        origin -&gt; map(|v| (v, ())) -&gt; [0]my_join;
        stream_of_edges -&gt; [1]my_join;

        // the output
        my_join -&gt; for_each(|n| println!(&quot;Reached: {}&quot;, n));
    };

    println!(
        &quot;{}&quot;,
        flow.serde_graph()
            .expect(&quot;No graph found, maybe failed to parse.&quot;)
            .to_mermaid()
    );
    pairs_send.send((0, 1)).unwrap();
    pairs_send.send((2, 4)).unwrap();
    pairs_send.send((3, 4)).unwrap();
    pairs_send.send((1, 2)).unwrap();
    pairs_send.send((0, 3)).unwrap();
    pairs_send.send((0, 3)).unwrap();
    flow.run_available();
}
</code></pre></pre>
<p>And the output:</p>
<pre><code class="language-txt">Reached: 1
Reached: 3
</code></pre>
<p>That looks right: the edges we &quot;sent&quot; into the flow that start at <code>0</code> are 
<code>(0, 1)</code> and <code>(0, 3)</code>.</p>
<p>As for the code itself, we start out with the origin vertex, <code>0</code>,
and the stream of edges coming in:</p>
<pre><code class="language-rust ignore">    origin = recv_iter(vec![0]);
    stream_of_edges = recv_stream(pairs_recv);
</code></pre>
<p>The Rust syntax <code>vec![0]</code> constructs a vector with a single element, <code>0</code>, which we iterate
over using <code>recv_iter</code>.</p>
<p>We then set up a <a href="./surface_ops.html#join"><code>join()</code></a> that we
name <code>my_join</code>, which acts like a SQL inner join. 
First, note the syntax for passing data into a subflow with multiple inputs <em>prepends</em> 
an input index (starting at <code>0</code>) in square brackets to the multi-input variable name or operator.  In this example we have <code>-&gt; [0]my_join</code>
and <code>-&gt; [1]my_join</code>.</p>
<p>Hydroflow's <code>join()</code> API requires
a little massaging of its inputs to work properly.
The inputs must be of the form of a pair of elements <code>(K, V1)</code>
and <code>(K, V2)</code>, and the operator joins them on equal keys <code>K</code> and produces an
output of <code>(K, (V1, V2))</code> elements. In this case we only want to join on the key <code>v</code> and
don't have any corresponding value, so we feed <code>origin</code> through a <a href="./surface_ops.html#map"><code>map()</code></a>
to generate <code>(v, ())</code> elements as the first join input. </p>
<pre><code class="language-rust ignore">    my_join = join() -&gt; map(|(_x, (_y, z))| z);
    origin -&gt; map(|v| (v, ())) -&gt; [0]my_join;
    stream_of_edges -&gt; [1]my_join;
</code></pre>
<p>The <code>stream_of_edges</code> are <code>(from, to)</code> pairs,
so the join's output is <code>(from, ((), to))</code> where <code>to</code> are new neighbor
vertices. So the <code>my_join</code> variable feeds the output of the join through a map to extract just the neighbor vertex.
Finally we print the neighbor vertices as follows:</p>
<pre><code class="language-rust ignore">    my_join -&gt; for_each(|n| println!(&quot;Reached: {}&quot;, n));
</code></pre>
<p>The remaining code runs the graph on example edge data. There's
also some extra code there, particularly <code>flow.to_mermaid()</code> which lets us
generate a diagram rendered by <a href="https://mermaid-js.github.io/">Mermaid</a> showing
the structure of the graph:</p>
<pre class="mermaid">flowchart TB
    subgraph &quot;sg_1v1 stratum Some(0)&quot;
        1v1[&quot;1v1 &lt;tt&gt;op_1v1: recv_iter(vec! [0])&lt;/tt&gt;&quot;]
        2v1[&quot;2v1 &lt;tt&gt;op_2v1: recv_stream(pairs_recv)&lt;/tt&gt;&quot;]
        5v1[&quot;5v1 &lt;tt&gt;op_5v1: map(| v | (v, ()))&lt;/tt&gt;&quot;]
        3v1[&quot;3v1 &lt;tt&gt;op_3v1: join()&lt;/tt&gt;&quot;]
        4v1[&quot;4v1 &lt;tt&gt;op_4v1: map(| (_x, (_y, z)) | z)&lt;/tt&gt;&quot;]
        6v1[&quot;6v1 &lt;tt&gt;op_6v1: for_each(| n | println! (&amp;quot;Reached: {}&amp;quot;, n))&lt;/tt&gt;&quot;]
    end


    1v1--&gt;5v1
    2v1--&gt;3v1
    3v1--&gt;4v1
    4v1--&gt;6v1
    5v1--&gt;3v1
</pre>
<p>If you read the <code>pairs_send</code> calls in the code carefully, you'll see that the example data 
has nodes (<code>2</code>, <code>4</code>) that are more than one hop away from <code>0</code>, which were
not output by our simple program. To extend this example to graph <em>reachability</em>, 
we need to recurse: find neighbors of our neighbors, neighbors of our neighbors' neighbors, and so on. In Hydroflow,
this is done by adding a loop to the flow, as we'll see <a href="example_4_1_surface.html">next</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-reachability"><a class="header" href="#graph-reachability">Graph Reachability</a></h1>
<!-- Note about monotonicity? -->
<p>To expand from graph neighbors to graph reachability, we want to find nodes that are connected not just to <code>origin</code>,
but also to nodes reachable <em>transitively</em> from <code>origin</code>. Said differently, a node is reachable from <code>origin</code> if it is
one of two cases: </p>
<ol>
<li>a neighbor of <code>origin</code> <em>or</em> </li>
<li>a neighbor of some other node that is itself reachable from <code>origin</code>. </li>
</ol>
<p>It turns out this is a very small change to our Hydroflow program! It will also illustrate an operator, <a href="./surface_ops.html#tee"><code>tee()</code></a>,
which has multiple outputs.</p>
<p>Essentially we want to take <em>all</em> the reached vertices we found in our graph neighbors program,
and treat them recursively just as we treated <code>origin</code>.
To do this in a language like Hydroflow, we introduce a cycle in the flow:
we take the join output and have it
flow back into the join input. The modified intuitive graph looks like this:</p>
<pre class="mermaid">graph TD
  subgraph recursive example
    00[Origin Vertex]
    01[Stream of Edges]
    10[Reached Vertices]
    20(&quot;V ⨝ E&quot;)
    40[Output]

    00 --&gt; 10
    10 --&gt; 20
    20 ---&gt; 10

    01 ---&gt; 20
    20 --&gt; 40
    
  end
</pre>
<p>Note that we added a <code>Reached Vertices</code> node to <code>merge</code> the two inbound edges corresponding to our 
two cases above. Similarly note that the join node <code>V ⨝ E</code> now has two <em>outbound</em> edges; the sketch omits the operator 
to copy (<code>tee</code>) the output along 
two paths.</p>
<p>Now lets look at a modified version of our <a href="example_4_surface.html">graph neighbor</a> code that implements this full program, including the loop as well as the <code>merge</code> and <code>tee</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use hydroflow::hydroflow_syntax;
</span>pub fn main() {
    // An edge in the input data = a pair of `usize` vertex IDs.
    let (pairs_send, pairs_recv) = tokio::sync::mpsc::unbounded_channel::&lt;(usize, usize)&gt;();

    let mut flow = hydroflow_syntax! {
        // inputs: the origin vertex (node 0) and stream of input edges
        origin = recv_iter(vec![0]);
        stream_of_edges = recv_stream(pairs_recv);
        reached_vertices = merge();
        origin -&gt; [0]reached_vertices;

        // the join
        my_join_tee = join() -&gt; map(|(_src, ((), dst))| dst) -&gt; tee();
        reached_vertices -&gt; map(|v| (v, ())) -&gt; [0]my_join_tee;
        stream_of_edges -&gt; [1]my_join_tee;

        // the loop and the output
        my_join_tee[0] -&gt; [1]reached_vertices;
        my_join_tee[1] -&gt; for_each(|x| println!(&quot;Reached: {}&quot;, x));
    };

    println!(
        &quot;{}&quot;,
        flow.serde_graph()
            .expect(&quot;No graph found, maybe failed to parse.&quot;)
            .to_mermaid()
    );
    pairs_send.send((0, 1)).unwrap();
    pairs_send.send((2, 4)).unwrap();
    pairs_send.send((3, 4)).unwrap();
    pairs_send.send((1, 2)).unwrap();
    pairs_send.send((0, 3)).unwrap();
    pairs_send.send((0, 3)).unwrap();
    flow.run_available();
}
</code></pre></pre>
<p>And now we get the full set of vertices reachable from <code>0</code>:</p>
<pre><code class="language-txt">Reached: 1
Reached: 3
Reached: 2
Reached: 4
Reached: 4
</code></pre>
<p>Let's review the significant changes here. First, in setting up the inputs we have the 
addition of the <code>reached_vertices</code> variable, which uses the <a href="./surface_ops.html#merge">merge()</a> 
op to merge the output of two operators into one. 
We route the <code>origin</code> node into it as one input right away:</p>
<pre><code class="language-rust ignore">    reached_vertices = merge();
    origin -&gt; [0]reached_vertices;
</code></pre>
<p>Note the square-bracket syntax for differentiating the multiple inputs to <code>merge()</code>
is the same as that of <code>join()</code> (except that merge can have an unbounded number of inputs,
whereas <code>join()</code> is defined to only have two.)</p>
<p>Now, <code>join()</code> is defined to only have one output. In our program, we want to copy 
the joined output 
output to two places: to the original <code>for_each</code> from above to print output, and <em>also</em> 
back to the <code>merge</code> operator we called <code>reached_vertices</code>.
We feed the <code>join()</code> output 
through a <code>map()</code> as before, and then we feed the result into a <a href="./surface_ops.html#tee"><code>tee()</code></a> operator,
which is the mirror image of <code>merge()</code>:  instead of merging many inputs to one output, 
it copies one input to many different outputs.  Each input element is <em>cloned</em>, in Rust terms, and
given to each of the outputs. The syntax for the outputs of <code>tee()</code> mirrors that of merge: we <em>append</em> 
an output index in square brackets to the <code>tee</code> or variable. In this example we have
<code>my_join_tee[0] -&gt;</code> and <code>my_join_tee[1] -&gt;</code>.</p>
<p>Finally, we process the output of the <code>join</code> as passed through the <code>tee</code>.
One branch pushes reached vertices back up into the <code>reached_vertices</code> variable (which begins with a <code>merge</code>), while the other
prints out all the reached vertices as in the simple program.</p>
<pre><code class="language-rust ignore">        my_join_tee[0] -&gt; [1]reached_vertices;
        my_join_tee[1] -&gt; for_each(|x| println!(&quot;Reached: {}&quot;, x));
</code></pre>
<p>Note the syntax for differentiating the <em>outputs</em> of a <code>tee()</code> is symmetric to that of <code>merge()</code>, 
showing up to the right of the variable rather than the left.</p>
<p>Below is the diagram rendered by <a href="https://mermaid-js.github.io/">Mermaid</a> showing
the structure of the full flow:</p>
<pre class="mermaid">flowchart TB
    subgraph sg_4294967297
        1v1[&quot;1v1 &lt;tt&gt;op_1v1: recv_iter(vec! [0])&lt;/tt&gt;&quot;]
        2v1[&quot;2v1 &lt;tt&gt;op_2v1: merge()&lt;/tt&gt;&quot;]
        3v1[&quot;3v1 &lt;tt&gt;op_3v1: map(| v | (v, ()))&lt;/tt&gt;&quot;]
        7v1[&quot;7v1 &lt;tt&gt;op_7v1: recv_stream(pairs_recv)&lt;/tt&gt;&quot;]
        4v1[&quot;4v1 &lt;tt&gt;op_4v1: join()&lt;/tt&gt;&quot;]
        5v1[&quot;5v1 &lt;tt&gt;op_5v1: map(| (_src, ((), dst)) | dst)&lt;/tt&gt;&quot;]
        6v1[&quot;6v1 &lt;tt&gt;op_6v1: tee()&lt;/tt&gt;&quot;]
        8v1[&quot;8v1 &lt;tt&gt;op_8v1: for_each(| x | println! (&amp;quot;Reached: {}&amp;quot;, x))&lt;/tt&gt;&quot;]
    end

    9v1{&quot;handoff&quot;}

    1v1--&gt;2v1
    2v1--&gt;3v1
    3v1--&gt;4v1
    4v1--&gt;5v1
    5v1--&gt;6v1
    6v1--&gt;9v1
    6v1--&gt;8v1
    7v1--&gt;4v1
    9v1--&gt;2v1
</pre>
<p>This is similar to the flow for graph neighbors, but has a few more operators that make it look
more complex. In particular, it includes the <code>merge</code> and <code>tee</code> operators, and a back-edge 
which passes through an auto-generated <code>handoff</code> operator. (<code>handoffs</code> are the way that Hydroflow's
runtime breaks dataflow cycles to simplify execution internally.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-un-reachability"><a class="header" href="#graph-un-reachability">Graph Un-Reachability</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<h2 id="dataflow-and-networking"><a class="header" href="#dataflow-and-networking">Dataflow and Networking</a></h2>
<p>Conventionally, dataflow systems provide a way to analyze and process data by
chaining functions (operators) together into pipelines. But with a change of
perspective, many computations can be represented as dataflow. Designing around
the flow of data naturally separates computation into easily parallelizable and
distributable pipelines.</p>
<p>Most dataflow systems provide opinionated mechanisms for running flows across
multiple machines. Hydroflow however aims to represent many more types of
computations besides just data processing. This includes networking protocols
like two-phase commit and Paxos. To this end, Hydroflow is unopinionated about
network communication. Additionally, Hydroflow provides the abstraction of only
a single node (single thread) of a system. To build up a distributed system,
the user must design each node to communicate with others as needed.</p>
<p>As development continues we will provide more utilities for common networking
use cases, but for now expect some manual management of IP addresses and
sockets.</p>
<h2 id="lattices"><a class="header" href="#lattices">Lattices</a></h2>
<h2 id="strata"><a class="header" href="#strata">Strata</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hydroflow-surface-syntax"><a class="header" href="#hydroflow-surface-syntax">Hydroflow Surface Syntax</a></h1>
<p>The natural way to write a Hydroflow program is using the <em>Surface Syntax</em> documented here. 
It is a chained <code>Iterator</code>-style syntax of operators built into Hydroflow that should be sufficient
for most uses. If you want lower-level access you can work with the <code>Core API</code> documented in the <a href="./architecture.html">Architecture</a> section.</p>
<p>In this chapter we go over the syntax piece by piece: how to <a href="./surface_embedding.html">embed surface syntax in Rust</a> and how to specify <a href="./surface_flows.html"><em>flows</em></a>, which consist of <a href="./surface_data.html"><em>data sources</em></a> flowing through <a href="./surface_ops.html"><em>operators</em></a>. In the <a href="surface_types.html">Hydroflow Types</a> chapter we dive into the details of the data types that pass through flows.</p>
<p>As a teaser, here is a Rust/Hydroflow &quot;HELLO WORLD&quot; program:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hydroflow::hydroflow_syntax;

pub fn test_hello_world() {
    let mut df = hydroflow_syntax! {
        recv_iter(vec![&quot;hello&quot;, &quot;world&quot;])
            -&gt; map(|x| x.to_uppercase()) -&gt; for_each(|x| println!(&quot;{}&quot;, x));
    };
    df.run_available();
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedding-a-flow-in-rust"><a class="header" href="#embedding-a-flow-in-rust">Embedding a Flow in Rust</a></h1>
<p>Hydroflow's surface syntax is typically used within a Rust program. (An interactive client and/or external language bindings are TBD.)</p>
<p>The surface syntax is embedded into Rust via a macro as follows</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hydroflow::hydroflow_syntax;

pub fn example() {
    let mut flow = hydroflow_syntax! {
        // Hydroflow Surface Syntax goes here
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>The resulting <code>flow</code> object is of type <code>Hydroflow</code>; see the documentation on the 
<a href="./hydroflow_object.html">Hydroflow Object</a> for details on how to use the result.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-syntax"><a class="header" href="#flow-syntax">Flow Syntax</a></h1>
<p>Flows consist of named <em>operators</em> that are connected via flow <em>edges</em> denoted by <code>-&gt;</code>. The example below
uses the <a href="./surface_ops.html#recv_iter"><code>recv_iter</code></a> operator to generate two strings from a Rust <code>vec</code>, the 
<a href="./surface_ops.html#map"><code>map</code></a> operator to apply some Rust code to uppercase each string, and the <a href="./surface_ops.html#for_each"><code>for_each</code></a> 
operator to print each string to stdout.</p>
<pre><code class="language-rust ignore">recv_iter(vec![&quot;Hello&quot;, &quot;world&quot;]) 
    -&gt; map(|x| x.to_uppercase()) -&gt; for_each(|x| println!(&quot;{}&quot;, x));
</code></pre>
<p>Flows can be assigned to variable names for convenience. E.g, the above can be rewritten as follows:</p>
<pre><code class="language-rust ignore">upper_print = map(|x| x.to_uppercase()) -&gt; for_each(|x| println!(&quot;{}&quot;, x));
recv_iter(vec![&quot;Hello&quot;, &quot;world&quot;]) -&gt; upper_print;
</code></pre>
<h2 id="operators-with-multiple-ports"><a class="header" href="#operators-with-multiple-ports">Operators with Multiple Ports</a></h2>
<p>Some operators have more than one input <em>port</em> that can be referenced by <code>-&gt;</code>. For example <a href="./surface_ops.html#merge"><code>merge</code></a> 
merges the contents of many flows, so it can have an abitrary number of input ports. Some operators have multiple outputs, notably <a href="./surface_ops.html#tee"><code>tee</code></a>,
which has an arbitrary number of outputs. </p>
<p>In the syntax, we distinguish input ports via an <em>indexing prefix</em> number
in square brackets before the operator name (e.g. <code>[0]merge(...)</code> and <code>[1]merge(...)</code>). We 
distinguish output ports by an <em>indexing suffix</em> (e.g. <code>tee[0]</code>). </p>
<p>Here is an example that tees one flow into two, handles each separately, and then merges them to print out the contents in both lowercase and uppercase:</p>
<pre><code class="language-rust ignore">source = recv_iter(vec![&quot;Hello&quot;, &quot;world&quot;]) -&gt; tee();
print = merge() -&gt; for_each(|x| println!(&quot;{}&quot;, x));
source[0] -&gt; map(|x: &amp;str| x.to_uppercase()) -&gt; [0]print;
source[1] -&gt; map(|x: &amp;str| x.to_lowercase()) -&gt; [1]print;
</code></pre>
<p>(Note that the Rust code inside map needed a little help with type inference after the <code>tee</code>.)</p>
<p>Here is a visualization of the flow that was generated:</p>
<pre class="mermaid">flowchart TB
    subgraph Compiled Component 2
        3v1[&quot;3v1 &lt;tt&gt;op_3v1: merge()&lt;/tt&gt;&quot;]
        4v1[&quot;4v1 &lt;tt&gt;op_4v1: for_each(| x | println! (&amp;quot;{}&amp;quot;, x))&lt;/tt&gt;&quot;]
    end
    subgraph Compiled Component 1
        1v1[&quot;1v1 &lt;tt&gt;op_1v1: recv_iter(vec! [&amp;quot;Hello&amp;quot;, &amp;quot;world&amp;quot;])&lt;/tt&gt;&quot;]
        2v1[&quot;2v1 &lt;tt&gt;op_2v1: tee()&lt;/tt&gt;&quot;]
        5v1[&quot;5v1 &lt;tt&gt;op_5v1: map(| x : &amp;amp; str | x.to_uppercase())&lt;/tt&gt;&quot;]
        6v1[&quot;6v1 &lt;tt&gt;op_6v1: map(| x : &amp;amp; str | x.to_lowercase())&lt;/tt&gt;&quot;]
    end

    7v1{&quot;handoff&quot;}
    8v1{&quot;handoff&quot;}

    1v1--&gt;2v1
    2v1--&gt;5v1
    2v1--&gt;6v1
    3v1--&gt;4v1
    5v1--&gt;7v1
    6v1--&gt;8v1
    7v1--&gt;3v1
    8v1--&gt;3v1
</pre>
<p>Hydroflow compiled this flow into two subgraphs called <em>compiled components</em>, connected by <em>handoffs</em>. You can ignore 
these details unless you are interested in low-level performance tuning; they are explained in the discussion
of <a href="./in-out_trees.html">in-out trees</a>. </p>
<h3 id="a-note-on-assigning-flows-with-multiple-ports"><a class="header" href="#a-note-on-assigning-flows-with-multiple-ports">A note on assigning flows with multiple ports</a></h3>
<blockquote>
<p><em>WARNING</em>: <em>Need to document the port numbers for variables assigned to tree- or dag-shaped flows</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-sources-and-sinks-in-rust"><a class="header" href="#data-sources-and-sinks-in-rust">Data Sources and Sinks in Rust</a></h1>
<p>Any useful flow requires us to define sources of data, either generated computationally or received from 
and outside environment via I/O.</p>
<h2 id="recv_iter"><a class="header" href="#recv_iter"><code>recv_iter</code></a></h2>
<p>A flow can receive data from a Rust collection object via the <code>recv_iter</code> operator, which takes the 
iterable collection as an argument and passes the items down the flow. 
For example, here we iterate through a vector of <code>usize</code> items and push them down the flow:</p>
<pre><code class="language-rust ignore">    recv_iter(vec![0, 1]) -&gt; ...
</code></pre>
<p>The Hello, World example above uses this construct.</p>
<h2 id="recv_stream"><a class="header" href="#recv_stream"><code>recv_stream</code></a></h2>
<p>More commonly, a flow should handle external data coming in asynchronously from a <a href="https://tokio.rs/tokio/tutorial"><em>Tokio</em> runtime</a>.
One way to do this is with <em>channels</em> that allow Rust code to send data into the Hydroflow inputs.
The code below creates a channel for data of (Rust) type <code>(usize, usize)</code>:</p>
<pre><code class="language-rust ignore">    let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;(usize, usize)&gt;();
</code></pre>
<p>Under the hood this uses <a href="https://docs.rs/tokio/latest/tokio/sync/mpsc/fn.unbounded_channel.html">Tokio unbounded channels</a>.
Now in Rust we can now push data into the channel. E.g. for testing we can do
it explicitly as follows:</p>
<pre><code class="language-rust ignore">    input_send.send((0, 1)).unwrap()
</code></pre>
<p>And in our Hydroflow syntax we can receive the data from the channel using the <code>recv_stream</code> syntax and
pass it along a flow:</p>
<pre><code class="language-rust ignore">    recv_stream(input_recv) -&gt; ...
</code></pre>
<p>To put this together, let's revisit our Hello, World example from above with data sent 
in from outside the flow:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use hydroflow::hydroflow_syntax;
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;&amp;str&gt;();
let mut flow = hydroflow_syntax! {
    recv_stream(input_recv) -&gt; map(|x| x.to_uppercase())
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
};
input_send.send(&quot;Hello&quot;).unwrap();
input_send.send(&quot;World&quot;).unwrap();
flow.run_available();
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- GENERATED "hydroflow_macro/build.rs" -->
<h1 id="hydroflows-built-in-operators"><a class="header" href="#hydroflows-built-in-operators">Hydroflow's Built-in Operators</a></h1>
<p>In our previous examples we made use of some of Hydroflow's built-in operators.
Here we document each operators in more detail. Most of these operators
are based on the Rust equivalents for iterators; see the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Rust documentation</a>.</p>
<h2 id="null"><a class="header" href="#null"><code>null</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="at least 0">at least 0</span></td><td><code>null()</code></td><td><span title="at least 0">at least 0</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/null.rs" -->
<blockquote>
<p>unbounded number of input streams of any types, unbounded number of output streams of type <code>()</code></p>
</blockquote>
<p>As a source, generates nothing. As a sink, absorbs anything with no effect.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print `1, 2, 3, 4, 5, 6, a, b, c` across 9 lines
null() -&gt; for_each(|_: ()| panic!());
recv_iter([1,2,3]) -&gt; map(|i| println!(&quot;{}&quot;, i)) -&gt; null();
null_src = null();
null_sink = null();
null_src[0] -&gt; for_each(|_: ()| panic!());
// note: use `for_each()` (or `inspect()`) instead of this:
recv_iter([4,5,6]) -&gt; map(|i| println!(&quot;{}&quot;, i)) -&gt; [0]null_sink;
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="merge"><a class="header" href="#merge"><code>merge</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="at least 0">at least 2</span></td><td><code>-&gt; merge() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/merge.rs" -->
<blockquote>
<p><em>n</em> input streams of the same type, 1 output stream of the same type</p>
</blockquote>
<p>Merges an arbitrary number of input streams into a single stream. Each input sequence is a subsequence of the output, but no guarantee is given on how the inputs are interleaved.</p>
<p>Since <code>merge</code> has multiple input streams, it needs to be assigned to
a variable to reference its multiple input ports across statements.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>my_merge = merge();
recv_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; my_merge;
recv_iter(vec![&quot;stay&quot;, &quot;gold&quot;]) -&gt; my_merge;
recv_iter(vec![&quot;don\'t&quot;, &quot;give&quot;, &quot;up&quot;]) -&gt; my_merge;
my_merge -&gt; map(|x| x.to_uppercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="join"><a class="header" href="#join"><code>join</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 2">exactly 2</span></td><td><code>-&gt; join() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<blockquote>
<p>Input port names: <code>0</code>, <code>1</code></p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/join.rs" -->
<blockquote>
<p>2 input streams of type &lt;(K, V1)&gt; and &lt;(K, V2)&gt;, 1 output stream of type &lt;(K, (V1, V2))&gt;</p>
</blockquote>
<p>Forms the equijoin of the tuples in the input streams by their first (key) attribute. Note that the result nests the 2nd input field (values) into a tuple in the 2nd output field.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print `(hello, (world, cleveland))`
my_join = join();
recv_iter(vec![(&quot;hello&quot;, &quot;world&quot;), (&quot;stay&quot;, &quot;gold&quot;)]) -&gt; [0]my_join;
recv_iter(vec![(&quot;hello&quot;, &quot;cleveland&quot;)]) -&gt; [1]my_join;
my_join -&gt; for_each(|(k, (v1, v2))| println!(&quot;({}, ({}, {}))&quot;, k, v1, v2));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="cross_join"><a class="header" href="#cross_join"><code>cross_join</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 2">exactly 2</span></td><td><code>-&gt; cross_join() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<blockquote>
<p>Input port names: <code>0</code>, <code>1</code></p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/cross_join.rs" -->
<blockquote>
<p>2 input streams of type S and T, 1 output stream of type (S, T)</p>
</blockquote>
<p>Forms the cross-join (Cartesian Product) of the items in the input streams, returning all tupled pairs.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print all 4 pairs of emotion and animal
my_join = cross_join();
recv_iter(vec![&quot;happy&quot;, &quot;sad&quot;]) -&gt; [0]my_join;
recv_iter(vec![&quot;dog&quot;, &quot;cat&quot;]) -&gt; [1]my_join;
my_join -&gt; for_each(|(v1, v2)| println!(&quot;({}, {})&quot;, v1, v2));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="tee"><a class="header" href="#tee"><code>tee</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; tee() -&gt;</code></td><td><span title="at least 0">at least 2</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/tee.rs" -->
<blockquote>
<p>1 input stream, <em>n</em> output streams</p>
</blockquote>
<p>Takes the input stream and delivers a copy of each item to each output.</p>
<blockquote>
<p>Note: Downstream operators may need explicit type annotations.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>my_tee = recv_iter(vec![&quot;Hello&quot;, &quot;World&quot;]) -&gt; tee();
my_tee -&gt; map(|x: &amp;str| x.to_uppercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
my_tee -&gt; map(|x: &amp;str| x.to_lowercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
my_tee -&gt; for_each(|x: &amp;str| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="identity"><a class="header" href="#identity"><code>identity</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; identity() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/identity.rs" -->
<blockquote>
<p>1 input stream of type T, 1 output stream of type T</p>
</blockquote>
<p>For each item passed in, pass it out without any change.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print &quot;hello&quot; and &quot;world&quot; on separate lines (in either order)
recv_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; identity()
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="map"><a class="header" href="#map"><code>map</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; map(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/map.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: A Rust closure
For each item passed in, apply the closure to generate an item to emit.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>recv_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; map(|x| x.to_uppercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="inspect"><a class="header" href="#inspect"><code>inspect</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; inspect(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/inspect.rs" -->
<h2 id="flat_map"><a class="header" href="#flat_map"><code>flat_map</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; flat_map(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/flat_map.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: A Rust closure that handles an iterator</p>
</blockquote>
<p>For each item <code>i</code> passed in, treat <code>i</code> as an iterator and map the closure to that
iterator to produce items one by one. The type of the input items must be iterable.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print out each character of each word on a separate line
recv_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; flat_map(|x| x.chars())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="flatten"><a class="header" href="#flatten"><code>flatten</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; flatten() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/flatten.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<p>For each item <code>i</code> passed in, treat <code>i</code> as an iterator and produce its items one by one.
The type of the input items must be iterable.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print the numbers 1-6 without any nesting
recv_iter(vec![[1, 2], [3, 4], [5, 6]]) -&gt; flatten()
-&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="filter_map"><a class="header" href="#filter_map"><code>filter_map</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; filter_map(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/filter_map.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<p>An operator that both filters and maps. It yields only the items for which the supplied closure returns <code>Some(value)</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>recv_iter(vec![&quot;1&quot;, &quot;hello&quot;, &quot;world&quot;, &quot;2&quot;]) -&gt; filter_map(|s| s.parse().ok())
    -&gt; for_each(|x: usize| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="filter"><a class="header" href="#filter"><code>filter</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; filter(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/filter.rs" -->
<p>Filter outputs a subsequence of the items it receives at its input, according to a
Rust boolean closure passed in as an argument.</p>
<blockquote>
<p>TODO: Why does filter's closure expect a reference and other ops like map do not?</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>recv_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; filter(|x| x.starts_with('w'))
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="fold"><a class="header" href="#fold"><code>fold</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; fold(A, B) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/fold.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: an initial value, and a closure which itself takes two arguments:
an 'accumulator', and an element. The closure returns the value that the accumulator should have for the next iteration.</p>
</blockquote>
<p>Akin to Rust's built-in fold operator. Folds every element into an accumulator by applying a closure,
returning the final result.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print `Reassembled vector [1,2,3,4,5]`
recv_iter([1,2,3,4,5])
    -&gt; fold(Vec::new(), |mut accum, elem| {
        accum.push(elem);
        accum
    })
    -&gt; for_each(|e| println!(&quot;Ressembled vector {:?}&quot;, e));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="reduce"><a class="header" href="#reduce"><code>reduce</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; reduce(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/reduce.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: a closure which itself takes two arguments:
an ‘accumulator’, and an element. The closure returns the value that the accumulator should have for the next iteration.</p>
</blockquote>
<p>Akin to Rust's built-in reduce operator. Folds every element into an accumulator by applying a closure,
returning the final result.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print 120 (i.e., 1*2*3*4*5)
recv_iter([1,2,3,4,5])
    -&gt; reduce(|mut accum, elem| {
        accum *= elem;
        accum
    })
    -&gt; for_each(|e| println!(&quot;{}&quot;, e));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="groupby"><a class="header" href="#groupby"><code>groupby</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; groupby(A, B) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/groupby.rs" -->
<blockquote>
<p>1 input stream of type (K,V1), 1 output stream of type (K,V2).
The output will have one tuple for each distinct K, with an accumulated value of type V2.</p>
</blockquote>
<blockquote>
<p>Arguments: two Rust closures. The first generates an initial value per group. The second itself takes two arguments:
an 'accumulator', and an element. The second closure returns the value that the accumulator should have for the next iteration.</p>
</blockquote>
<p>A special case of <code>fold</code>, in the spirit of SQL's GROUP BY and aggregation constructs.
The input is partitioned into groups by the first field, and for each group the values in the second field
are accumulated via the closures in the arguments.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>recv_iter([(&quot;toy&quot;, 1), (&quot;toy&quot;, 2), (&quot;shoe&quot;, 11), (&quot;shoe&quot;, 35), (&quot;haberdashery&quot;, 7)])
    -&gt; groupby(|| 0, |old: &amp;mut u32, val: u32| *old += val)
    -&gt; for_each(|(k, v)| println!(&quot;Total for group {} is {}&quot;, k, v));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="unique"><a class="header" href="#unique"><code>unique</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; unique() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/unique.rs" -->
<p>Takes one stream as input and filters out any duplicate occurrences. The output
contains all unique values from the input.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print 1, 2, 3 (in any order)
recv_iter(vec![1, 1, 2, 3, 2, 1, 3])
    -&gt; unique()
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="sort"><a class="header" href="#sort"><code>sort</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; sort() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/sort.rs" -->
<p>Takes a stream as input and produces a sorted version of the stream as output.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print 1, 2, 3 (in order)
recv_iter(vec![2, 3, 1])
    -&gt; sort()
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="recv_stream-1"><a class="header" href="#recv_stream-1"><code>recv_stream</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>recv_stream(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/recv_stream.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: The receive end of a tokio channel</p>
</blockquote>
<p>Given a <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a>
created in Rust code, <code>recv_stream</code>
is passed the receive endpoint of the channel and emits each of the
elements it receives downstream.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;&amp;str&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    recv_stream(input_recv) -&gt; map(|x| x.to_uppercase())
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
};
input_send.send(&quot;Hello&quot;).unwrap();
input_send.send(&quot;World&quot;).unwrap();
flow.run_available();
<span class="boring">}
</span></code></pre></pre>
<h2 id="recv_iter-1"><a class="header" href="#recv_iter-1"><code>recv_iter</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>recv_iter(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/recv_iter.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: An iterable Rust object.
Takes the iterable object and delivers its elements downstream
one by one.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>    recv_iter(vec![&quot;Hello&quot;, &quot;World&quot;])
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="repeat_iter"><a class="header" href="#repeat_iter"><code>repeat_iter</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>repeat_iter(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/repeat_iter.rs" -->
<h2 id="difference"><a class="header" href="#difference"><code>difference</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 2">exactly 2</span></td><td><code>-&gt; difference() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<blockquote>
<p>Input port names: <code>pos</code>, <code>neg</code></p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/difference.rs" -->
<blockquote>
<p>2 input streams of the same type T, 1 output stream of type T</p>
</blockquote>
<p>Forms the set difference of the items in the input streams, returning items in the <code>pos</code>
input that are not found in the <code>neg</code> input</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print &quot;elephant&quot;
diff = difference();
recv_iter(vec![&quot;dog&quot;, &quot;cat&quot;, &quot;elephant&quot;]) -&gt; [pos]diff;
recv_iter(vec![&quot;dog&quot;, &quot;cat&quot;, &quot;gorilla&quot;]) -&gt; [neg]diff;
diff -&gt; for_each(|v| println!(&quot;{}&quot;, v));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="next_stratum"><a class="header" href="#next_stratum"><code>next_stratum</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; next_stratum() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/next_stratum.rs" -->
<h2 id="next_epoch"><a class="header" href="#next_epoch"><code>next_epoch</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; next_epoch() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/next_epoch.rs" -->
<h2 id="for_each"><a class="header" href="#for_each"><code>for_each</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; for_each(A)</code></td><td><span title="exactly 0">exactly 0</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/for_each.rs" -->
<blockquote>
<p>1 input stream, 0 output streams</p>
</blockquote>
<blockquote>
<p>Arguments: a Rust closure</p>
</blockquote>
<p>Iterates through a stream passing each element to the closure in the
argument.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>    recv_iter(vec![&quot;Hello&quot;, &quot;World&quot;])
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">__hf.run_available();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="write_async"><a class="header" href="#write_async"><code>write_async</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; write_async(A)</code></td><td><span title="exactly 0">exactly 0</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/write_async.rs" -->
<h2 id="sink_async"><a class="header" href="#sink_async"><code>sink_async</code></a></h2>
<table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; sink_async(A)</code></td><td><span title="exactly 0">exactly 0</span></td></tr>
</tbody></table>
<!-- GENERATED "hydroflow_lang/src/graph/ops/sink_async.rs" -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>Hydroflow graphs are divided into two layers: the outer <em>scheduled layer</em> and
inner <em>compiled layer</em>.</p>
<p>The <a href="https://hydro-project.github.io/hydroflow/design_docs/2021-10_architecture_design_doc.html">Hydroflow Architecture Design Doc</a>
contains a more detailed explanation of this section. Note that some aspects of
the design doc are not implemented (e.g. early yielding) or may become out of
date as time passes.</p>
<h2 id="scheduled-layer"><a class="header" href="#scheduled-layer">Scheduled Layer</a></h2>
<p>The scheduled layer is dynamic: it stores a list of operators (or &quot;subgraphs&quot;)
as well as buffers (&quot;handoffs&quot;) between them. The scheduled layer chooses how
to schedule the operators (naturally), and when each operator runs it pulls
from its input handoffs and pushes to its output handoffs. This setup is
extremely flexible: operators can have any number of input or output handoffs
so we can easily represent any graph topology. However this flexibility comes
at a performance cost due to the overhead of scheduling, buffering, and lack
of inter-operator compiler optimization.</p>
<p>The <em>compiled layer</em> helps avoids the costs of the scheduled layer. We can
combine several operators into a <em>subgraph</em> which are compiled and optimized as
a single scheduled subgraph. The scheduled layer then runs the entire subgraph
as if it was one operator with many inputs and outputs. Note the layering here:
the compiled layer does not replace the scheduled layer but instead exists
within it.</p>
<h2 id="compiled-layer"><a class="header" href="#compiled-layer">Compiled Layer</a></h2>
<p>Rust already has a built-in API similar to dataflow: <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code>s</a>.
When they work well, they work really well and tend to be as fast as for loops.
However, they are limited in the flow graphs they can represent. Each operator
in a <code>Iterator</code> takes ownership of, and <em>pulls</em> from, the previous operator.
Taking two iterators as <em>inputs</em> and merging them together (e.g. with
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain"><code>.chain(...)</code></a>
or <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.zip"><code>.zip(...)</code></a>)
is natural and performant as we can <em>pull</em> from both. However if we want an
iterator to split into multiple <em>outputs</em> then things become tricky. <a href="https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.tee"><code>Itertools::tee()</code></a>
does just this by cloning each incoming item into two output buffers, but this
requires allocation and could cause unbounded buffer growth if the outputs are
not read from evenly.</p>
<p>However, if instead iterators were <em>push</em>-based, where each operator owns one
or more <em>output</em> operators, then teeing is very easy, just clone each element
and push to (i.e. run) both outputs. So that's what we did, created push-based
iterators to allow fast teeing or splitting in the compiled layer.</p>
<p>Pull-based iterators can be connected to push-based iterators at a single &quot;pivot&quot;
point. Together, this pull-to-push setup dictates the shape compiled subgraphs
can take. Informally, this is like the roots and leaves of a tree. Water flows
from the roots (the pull inputs), eventually all join together in the trunk
(the pull-to-push pivot), the split up into multiple outputs in the leaves.
We refer to this structure as an <em>in-out tree</em>.</p>
<table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/oaklandish_logo.jpg" alt="The Oaklandish Logo depicting the stylized roots, trunk, and branches of a tree." /></td></tr>
<tr><td style="text-align: center">The Oaklandish Logo.</td></tr>
</tbody></table>
<p>See <a href="./in-out_trees.html">Subgraph In-Out Trees</a> for more, including how to
convert a graph into in-out trees.</p>
<h2 id="surface-syntax-and-apis"><a class="header" href="#surface-syntax-and-apis">Surface Syntax and APIs</a></h2>
<p>You can interact with Hydroflow at a high level with a <em>Surface Syntax</em> that hides
the distinction between these two layers. It offers a natural <code>Iterator</code>-like chaining syntax for building 
graphs that get parsed and compiled into a scheduled graph of one or more compiled subgraphs. Please see the <a href="./surface_syntax.html">Surface Syntax</a> docs for more information.</p>
<blockquote>
<p><strong>Deprecated</strong>:  There is a <em>Surface API</em> that provides an <code>Iterator</code>-like chaining syntax in Rust. The Surface API code lives in <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/index.html"><code>hydroflow::builder</code></a>. Some of the examples still use this API.</p>
</blockquote>
<p>Alternatively, the <em>Core API</em> allows you to interact with handoffs directly at a low
level. It doesn't provide any notion of chainable operators. You can use Rust <code>Iterator</code>s
or any other arbitrary Rust code to implement the operators.</p>
<p>The Core API lives in <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/index.html"><code>hydroflow::scheduled</code></a>,
mainly in methods on the <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html"><code>Hydroflow</code> struct</a>.  Compiled push-based iterators live in <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/compiled/index.html"><code>hydroflow::compiled</code></a>. We intend users to use the Surface Syntax as it is much more friendly, but as
Hydroflow is in active development some operators might not be available in
the Surface Syntax, in which case the Core API can be used instead. If you find
yourself in this sitation be sure to <a href="https://github.com/hydro-project/hydroflow/issues/new">submit an issue</a>!</p>
<h2 id="scheduling"><a class="header" href="#scheduling">Scheduling</a></h2>
<h2 id="handoffs"><a class="header" href="#handoffs">Handoffs</a></h2>
<h2 id="networking"><a class="header" href="#networking">Networking</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subgraph-in-out-trees"><a class="header" href="#subgraph-in-out-trees">Subgraph In-Out Trees</a></h1>
<p>Formally, we define an in-out-tree is the union of an
<em>in-tree</em> (<a href="https://en.wikipedia.org/wiki/Arborescence_%28graph_theory%29#cite_ref-KorteVygen2012b_17-0"><em>anti-arborescence</em></a>)
with an <em>out-tree</em> (<a href="https://en.wikipedia.org/wiki/Arborescence_%28graph_theory%29"><em>arborescence</em></a>)
where both trees share the same <em>root</em> node.</p>
<table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/in-out_tree.png" alt="A graph showing multiple nodes on the left all eventually feeding into a central pivot node, then continuing to multiple output nodes." /></td></tr>
<tr><td style="text-align: center">An <em>in-out tree</em> graph. Data flows from the green <em>pull</em> operators on the left, through the yellow pivot, and to the red <em>push</em> operators on the right.</td></tr>
</tbody></table>
<p>In this graph representation, each node corresponds to an operator, and the
edges direct the flow of data between operators.</p>
<h2 id="converting-graph"><a class="header" href="#converting-graph">Converting Graph</a></h2>
<p>Any graph can be partitioned into in-out trees. Any non-trivial graph will have many possible
partitionings to choose from; a useful heuristic is to partition the graph
into as few subgraphs as possible, in order to minimize scheduling overheads.</p>
<p>Most graphs are pretty simple and can be partitioned with a bit of eye-balling.
To do this systematically, we can use a simple
coloring algorithm.</p>
<table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/in-out_example.png" alt="A random-looking directed graph with 8 nodes." /></td></tr>
<tr><td style="text-align: center">An example directed graph.</td></tr>
</tbody></table>
<p>To identify the in-out trees in an arbitrary directed graph, first identify any
nodes which have multiple inputs and outputs and mark these as pull-to-push
<em>pivots</em> (yellow in the example). Mark any nodes with multiple inputs (and a
single output) as <em>pull</em> (green) and any nodes with multiple outputs as <em>push</em>
(red).</p>
<p>In the example:</p>
<table><thead><tr><th>Pivots (yellow)</th><th>Pulls (green)</th><th>Pushes (red)</th></tr></thead><tbody>
<tr><td>1, 4</td><td>2</td><td>3, 7</td></tr>
</tbody></table>
<p>Finally any one-in-one-out nodes should be marked the same as their neighbors
(either green pull or red push). If we have green pull -&gt; red push that becomes
a yellow pivot. And if red push -&gt; green pull that becomes a blue handoff node,
and this is a division between subgraphs. Note that a subgraph can have a
handoff with itself; this forms a loop.</p>
<table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/in-out_partition.png" alt="The graph above converted and partitioned into two in-out trees." /></td></tr>
<tr><td style="text-align: center">The graph above converted and partitioned into two in-out trees. One is outlined in yellow and the other in red. For the corresponding Hydroflow graph, green nodes are <em>pull</em>, red nodes are <em>push</em>, yellow are <em>pivots</em>, and blue are <em>handoffs</em>.</td></tr>
</tbody></table>
<p>In the example partitioning above, some nodes have been split into multiple and
labelled with suffixes to make the pivots and handoffs more explicit.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
