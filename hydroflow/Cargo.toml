[package]
name = "hydroflow"
publish = true
version = "0.8.0"
edition = "2021"
license = "Apache-2.0"
documentation = "https://docs.rs/hydroflow/"
description = "Hydro's low-level dataflow runtime and IR"

[features]
default = [ "macros" ] # "nightly", "debugging" ]

nightly = [ "hydroflow_macro", "hydroflow_macro/diagnostics" ]
macros = [ "hydroflow_macro", "hydroflow_datalog" ]
hydroflow_macro = [ "dep:hydroflow_macro" ]
hydroflow_datalog = [ "dep:hydroflow_datalog" ]
deploy_integration = [ "dep:hydroflow_deploy_integration" ]
python = [ "dep:pyo3" ]
debugging = [ "hydroflow_lang/debugging" ]

[[example]]
name = "kvs_bench"
required-features = [ "nightly" ]

[[example]]
name = "kvs_mut"
required-features = [ "debugging" ]

[[example]]
name = "python_udf"
required-features = [ "python" ]

[dependencies]
bincode = "1.3"
byteorder = "1.4.3"
bytes = "1.1.0"
futures = "0.3.0"
hydroflow_deploy_integration = { optional = true, path = "../hydro_deploy/hydroflow_deploy_integration", version = "^0.5.2" }
hydroflow_datalog = { optional = true, path = "../hydroflow_datalog", version = "^0.8.0" }
hydroflow_lang = { path = "../hydroflow_lang", version = "^0.8.0" }
hydroflow_macro = { optional = true, path = "../hydroflow_macro", version = "^0.8.0" }
itertools = "0.10"
lattices = { path = "../lattices", version = "^0.5.6", features = [ "serde" ] }
pusherator = { path = "../pusherator", version = "^0.0.7" }
pyo3 = { optional = true, version = "0.20" }
ref-cast = "1.0"
regex = "1.10.4"
rustc-hash = "1.1.0"
sealed = "0.5"
serde = { version = "1.0.197", features = [ "derive" ] }
serde_json = "1.0.115"
slotmap = "1.0"
smallvec = "1.10.0"
tokio-stream = { version = "0.1.3", default-features = false, features = [ "time", "io-util", "sync" ] }
tracing = "0.1.37"
variadics = { path = "../variadics", version = "^0.0.5" }
web-time = "1.0.0"

# added to workaround `cargo smart-release` https://github.com/Byron/cargo-smart-release/issues/16
multiplatform_test = { path = "../multiplatform_test", version = "^0.1.0", optional = true }

[target.'cfg(not(target_arch = "wasm32"))'.dependencies]
tokio = { version = "1.29.0", features = [ "full" ] }
tokio-util = { version = "0.7", features = [ "net", "codec" ] }

[target.'cfg(target_arch = "wasm32")'.dependencies]
tokio = { version = "1.29.0", features = [ "rt" , "sync", "macros", "io-util", "time" ] }
tokio-util = { version = "0.7", features = [ "codec" ] }
# We depend on getrandom transitively through rand. To compile getrandom to
# WASM, we need to enable its "js" feature. However, rand does not expose a
# passthrough to enable "js" on getrandom. As a workaround, we enable the
# getrandom js feature here; when the feature resolver computes the set of
# features for getrandom (unification), it will include "js".
getrandom = { version = "0.2.6", features = [ "js" ] }

[dev-dependencies]
chrono = { version = "0.4.20", features = [ "serde", "clock" ], default-features = false }
clap = { version = "4.5.4", features = [ "derive" ] }
colored = "2.0"
insta = "1.39"
multiplatform_test = { path = "../multiplatform_test", version = "^0.1.0" }
wasm-bindgen-test = "0.3.0"
rand = { version = "0.8.0", features = [ "small_rng" ] }
rand_distr = "0.4.3"
regex = "1.10.4"
static_assertions = "1.0.0"
time = "0.3"
tracing-subscriber = { version = "0.3", features = [ "env-filter" ] }
trybuild = "1"
zipf = "7"

[target.'cfg(not(target_arch = "wasm32"))'.dev-dependencies]
# Rayon (rust data-parallelism library) does not compile on WASM.
criterion = { version = "0.5.0", features = [ "async_tokio", "html_reports" ] }
