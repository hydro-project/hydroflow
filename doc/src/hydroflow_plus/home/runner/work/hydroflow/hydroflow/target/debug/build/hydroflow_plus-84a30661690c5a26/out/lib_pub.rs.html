<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/work/hydroflow/hydroflow/target/debug/build/hydroflow_plus-84a30661690c5a26/out/lib_pub.rs`."><title>lib_pub.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../../../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/rustdoc-fecee23daa4e8a6d.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../static.files/" data-current-crate="hydroflow_plus" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0-nightly (4ac7bcbaa 2024-09-04)" data-channel="nightly" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../../../../../../../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../../../../../../../../../../../../static.files/src-script-e66d777a5a92e9b2.js"></script><script defer src="../../../../../../../../../../../../src-files.js"></script><script defer src="../../../../../../../../../../../../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../../../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
</pre></div><pre class="rust"><code><span class="kw">pub use </span>std :: collections :: BTreeMap ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>hydroflow :: scheduled :: context :: Context ; <span class="kw">pub use </span>hydroflow :: scheduled :: graph :: Hydroflow ; <span class="kw">pub use </span>hydroflow :: * ; <span class="kw">pub use </span>lang :: graph :: { partition_graph , HydroflowGraph } ; <span class="kw">pub use </span>proc_macro2 :: TokenStream ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>stageleft :: runtime_support :: FreeVariable ; <span class="kw">pub use </span>stageleft :: Quoted ; <span class="kw">pub mod </span>runtime_support { <span class="kw">pub use </span>bincode ; } <span class="kw">pub mod </span>stream { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: hash :: Hash ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: ops :: Deref ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>hydroflow :: bytes :: Bytes ; <span class="kw">pub use </span>hydroflow :: futures :: Sink ; <span class="kw">pub use </span>hydroflow_lang :: parse :: Pipeline ; <span class="kw">pub use </span>serde :: de :: DeserializeOwned ; <span class="kw">pub use </span>serde :: Serialize ; <span class="kw">pub use </span>stageleft :: { q , IntoQuotedMut , Quoted } ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use super </span>:: staging_util :: get_this_crate ; <span class="kw">pub use crate </span>:: builder :: { <span class="self">self </span>, FlowState } ; <span class="kw">pub use crate </span>:: cycle :: { CycleCollection , CycleComplete } ; <span class="kw">pub use crate </span>:: ir :: { DebugInstantiate , HfPlusLeaf , HfPlusNode , HfPlusSource , TeeNode } ; <span class="kw">pub use crate </span>:: location :: { CanSend , ExternalBincodeStream , ExternalBytesPort , ExternalProcess , Location , LocationId , } ; <span class="kw">pub use crate </span>:: { Cluster , ClusterId , Optional , Process , Singleton } ; <span class="kw">pub use crate </span>:: stream :: Unbounded ; <span class="kw">pub use crate </span>:: stream :: Bounded ; <span class="kw">pub use crate </span>:: stream :: NoTick ; <span class="kw">pub use crate </span>:: stream :: Tick ; <span class="kw">pub use crate </span>:: stream :: Stream ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleComplete &lt; <span class="lifetime">'a </span>, Tick &gt; <span class="kw">for </span>Stream &lt; T , Bounded , Tick , N &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident) { <span class="kw">let </span>me = <span class="self">self </span>. defer_tick () ; me . flow_state . borrow_mut () . leaves . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled."</span>) . push (HfPlusLeaf :: CycleSink { ident , location_kind : me . location_kind , input : Box :: new (me . ir_node . into_inner ()) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleCollection &lt; <span class="lifetime">'a </span>, Tick &gt; <span class="kw">for </span>Stream &lt; T , Bounded , Tick , N &gt; { <span class="kw">type </span>Location = N ; <span class="kw">fn </span>create_source (ident : syn :: Ident , flow_state : FlowState , l : LocationId) -&gt; <span class="self">Self </span>{ Stream :: new (l , flow_state , HfPlusNode :: CycleSource { ident , location_kind : l , } ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleComplete &lt; <span class="lifetime">'a </span>, NoTick &gt; <span class="kw">for </span>Stream &lt; T , W , NoTick , N &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident) { <span class="self">self </span>. flow_state . borrow_mut () . leaves . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled."</span>) . push (HfPlusLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind , input : Box :: new (HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleCollection &lt; <span class="lifetime">'a </span>, NoTick &gt; <span class="kw">for </span>Stream &lt; T , W , NoTick , N &gt; { <span class="kw">type </span>Location = N ; <span class="kw">fn </span>create_source (ident : syn :: Ident , flow_state : FlowState , l : LocationId) -&gt; <span class="self">Self </span>{ Stream :: new (l , flow_state , HfPlusNode :: Persist (Box :: new (HfPlusNode :: CycleSource { ident , location_kind : l , })) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; T , W , C , N &gt; { <span class="kw">pub </span>(<span class="kw">crate</span>) <span class="kw">fn </span>new (location_kind : LocationId , flow_state : FlowState , ir_node : HfPlusNode ,) -&gt; <span class="self">Self </span>{ Stream { location_kind , flow_state , ir_node : RefCell :: new (ir_node) , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Clone , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Clone <span class="kw">for </span>Stream &lt; T , W , C , N &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ <span class="kw">if </span>! matches ! (<span class="self">self </span>. ir_node . borrow () . deref () , HfPlusNode :: Tee { .. }) { <span class="kw">let </span>orig_ir_node = <span class="self">self </span>. ir_node . replace (HfPlusNode :: Placeholder) ; * <span class="self">self </span>. ir_node . borrow_mut () = HfPlusNode :: Tee { inner : TeeNode (Rc :: new (RefCell :: new (orig_ir_node))) , } ; } <span class="kw">if let </span>HfPlusNode :: Tee { inner } = <span class="self">self </span>. ir_node . borrow () . deref () { Stream { location_kind : <span class="self">self </span>. location_kind , flow_state : <span class="self">self </span>. flow_state . clone () , ir_node : HfPlusNode :: Tee { inner : TeeNode (inner . <span class="number">0 </span>. clone ()) , } . into () , _phantom : PhantomData , } } <span class="kw">else </span>{ unreachable ! () } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; T , W , C , N &gt; { <span class="kw">pub fn </span>map &lt; U , F : Fn (T) -&gt; U + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt;) -&gt; Stream &lt; U , W , C , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Map { f : f . splice_fn1 () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>flat_map &lt; U , I : IntoIterator &lt; Item = U &gt; , F : Fn (T) -&gt; I + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; U , W , C , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: FlatMap { f : f . splice_fn1 () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter &lt; F : Fn (&amp; T) -&gt; bool + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; T , W , C , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Filter { f : f . splice_fn1_borrow () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter_map &lt; U , F : Fn (T) -&gt; <span class="prelude-ty">Option </span>&lt; U &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; U , W , C , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: FilterMap { f : f . splice_fn1 () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>cross_singleton &lt; O &gt; (<span class="self">self </span>, other : <span class="kw">impl </span>Into &lt; Optional &lt; O , Bounded , C , N &gt; &gt; ,) -&gt; Stream &lt; (T , O) , W , C , N &gt; <span class="kw">where </span>O : Clone , { <span class="kw">let </span>other : Optional &lt; O , Bounded , C , N &gt; = other . into () ; <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"cross_singleton must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: CrossSingleton (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>cross_product &lt; O &gt; (<span class="self">self </span>, other : Stream &lt; O , W , C , N &gt;) -&gt; Stream &lt; (T , O) , W , C , N &gt; <span class="kw">where </span>T : Clone , O : Clone , { <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"cross_product must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: CrossProduct (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>union (<span class="self">self </span>, other : Stream &lt; T , W , C , N &gt;) -&gt; Stream &lt; T , W , C , N &gt; { <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"union must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Union (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>unique (<span class="self">self</span>) -&gt; Stream &lt; T , W , C , N &gt; <span class="kw">where </span>T : Eq + Hash , { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Unique (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>dest_sink &lt; S : Unpin + Sink &lt; T &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, sink : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, S &gt;) { <span class="self">self </span>. flow_state . borrow_mut () . leaves . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled."</span>) . push (HfPlusLeaf :: DestSink { sink : sink . splice_typed () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; T , Bounded , Tick , N &gt; { <span class="kw">pub fn </span>all_ticks (<span class="self">self</span>) -&gt; Stream &lt; T , Unbounded , NoTick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>persist (<span class="self">self</span>) -&gt; Stream &lt; T , Bounded , Tick , N &gt; <span class="kw">where </span>T : Clone , { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>defer_tick (<span class="self">self</span>) -&gt; Stream &lt; T , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: DeferTick (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>inspect &lt; F : Fn (&amp; T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; T , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Inspect { f : f . splice_fn1_borrow () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>first (<span class="self">self</span>) -&gt; Optional &lt; T , Bounded , Tick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , <span class="self">self </span>. ir_node . into_inner () ,) } # [doc = <span class="string">" Allow this stream through if the other stream has elements, otherwise the output is empty."</span>] <span class="kw">pub fn </span>continue_if &lt; U &gt; (<span class="self">self </span>, signal : Optional &lt; U , Bounded , Tick , N &gt; ,) -&gt; Stream &lt; T , Bounded , Tick , N &gt; { <span class="self">self </span>. cross_singleton (signal . map (q ! (| _u | ()))) . map (q ! (| (d , _signal) | d)) } # [doc = <span class="string">" Allow this stream through if the other stream is empty, otherwise the output is empty."</span>] <span class="kw">pub fn </span>continue_unless &lt; U &gt; (<span class="self">self </span>, other : Optional &lt; U , Bounded , Tick , N &gt; ,) -&gt; Stream &lt; T , Bounded , Tick , N &gt; { <span class="self">self </span>. continue_if (other . into_stream () . count () . filter (q ! (| c | * c == <span class="number">0</span>))) } <span class="kw">pub fn </span>enumerate (<span class="self">self</span>) -&gt; Stream &lt; (usize , T) , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Enumerate (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>fold &lt; A , I : Fn () -&gt; A + <span class="lifetime">'a </span>, F : Fn (&amp; <span class="kw-2">mut </span>A , T) &gt; (<span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, I &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Singleton &lt; A , Bounded , Tick , N &gt; { Singleton :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Fold { init : init . splice_fn0 () . into () , acc : comb . splice_fn2_borrow_mut () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>reduce &lt; F : Fn (&amp; <span class="kw-2">mut </span>T , T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Optional &lt; T , Bounded , Tick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Reduce { f : comb . splice_fn2_borrow_mut () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>max (<span class="self">self</span>) -&gt; Optional &lt; T , Bounded , Tick , N &gt; <span class="kw">where </span>T : Ord , { <span class="self">self </span>. reduce (q ! (| curr , new | { <span class="kw">if </span>new &gt; * curr { * curr = new ; } })) } <span class="kw">pub fn </span>min (<span class="self">self</span>) -&gt; Optional &lt; T , Bounded , Tick , N &gt; <span class="kw">where </span>T : Ord , { <span class="self">self </span>. reduce (q ! (| curr , new | { <span class="kw">if </span>new &lt; * curr { * curr = new ; } })) } <span class="kw">pub fn </span>sort (<span class="self">self</span>) -&gt; Stream &lt; T , Bounded , Tick , N &gt; <span class="kw">where </span>T : Ord , { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Sort (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>count (<span class="self">self</span>) -&gt; Singleton &lt; usize , Bounded , Tick , N &gt; { <span class="self">self </span>. fold (q ! (|| <span class="number">0usize</span>) , q ! (| count , <span class="kw">_ </span>| * count += <span class="number">1</span>)) } <span class="kw">pub fn </span>delta (<span class="self">self</span>) -&gt; Stream &lt; T , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Delta (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; T , W , NoTick , N &gt; { <span class="kw">pub fn </span>tick_batch (<span class="self">self</span>) -&gt; Stream &lt; T , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>tick_prefix (<span class="self">self</span>) -&gt; Stream &lt; T , Bounded , Tick , N &gt; <span class="kw">where </span>T : Clone , { <span class="self">self </span>. tick_batch () . persist () } <span class="kw">pub fn </span>inspect &lt; F : Fn (&amp; T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt;) -&gt; Stream &lt; T , W , NoTick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Persist (Box :: new (HfPlusNode :: Inspect { f : f . splice_fn1_borrow () . into () , input : Box :: new (HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , })) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; T , W , NoTick , N &gt; { <span class="kw">pub fn </span>for_each &lt; F : Fn (T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt;) { <span class="self">self </span>. flow_state . borrow_mut () . leaves . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled."</span>) . push (HfPlusLeaf :: ForEach { input : Box :: new (HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , f : f . splice_fn1 () . into () , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; T , Unbounded , NoTick , N &gt; { <span class="kw">pub fn </span>sample_every (<span class="self">self </span>, duration : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, std :: time :: Duration &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Stream &lt; T , Unbounded , NoTick , N &gt; { <span class="kw">let </span>interval = duration . splice_typed () ; <span class="kw">let </span>samples = Stream :: &lt; tokio :: time :: Instant , Bounded , Tick , N &gt; :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state . clone () , HfPlusNode :: Source { source : HfPlusSource :: Interval (interval . into ()) , location_kind : <span class="self">self </span>. location_kind , } ,) ; <span class="self">self </span>. tick_batch () . continue_if (samples . first ()) . all_ticks () } <span class="kw">pub fn </span>fold &lt; A , I : Fn () -&gt; A + <span class="lifetime">'a </span>, F : Fn (&amp; <span class="kw-2">mut </span>A , T) &gt; (<span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, I &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Singleton &lt; A , Unbounded , NoTick , N &gt; { Singleton :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Persist (Box :: new (HfPlusNode :: Fold { init : init . splice_fn0 () . into () , acc : comb . splice_fn2_borrow_mut () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , })) ,) } <span class="kw">pub fn </span>reduce &lt; F : Fn (&amp; <span class="kw-2">mut </span>T , T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Optional &lt; T , Unbounded , NoTick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Persist (Box :: new (HfPlusNode :: Reduce { f : comb . splice_fn2_borrow_mut () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , })) ,) } <span class="kw">pub fn </span>max (<span class="self">self</span>) -&gt; Optional &lt; T , Unbounded , NoTick , N &gt; <span class="kw">where </span>T : Ord , { <span class="self">self </span>. reduce (q ! (| curr , new | { <span class="kw">if </span>new &gt; * curr { * curr = new ; } })) } <span class="kw">pub fn </span>min (<span class="self">self</span>) -&gt; Optional &lt; T , Unbounded , NoTick , N &gt; <span class="kw">where </span>T : Ord , { <span class="self">self </span>. reduce (q ! (| curr , new | { <span class="kw">if </span>new &lt; * curr { * curr = new ; } })) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; T , Bounded , C , N &gt; { <span class="kw">pub fn </span>filter_not_in (<span class="self">self </span>, other : Stream &lt; T , Bounded , C , N &gt;) -&gt; Stream &lt; T , Bounded , C , N &gt; <span class="kw">where </span>T : Eq + Hash , { <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"union must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Difference (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Clone , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; &amp; T , W , C , N &gt; { <span class="kw">pub fn </span>cloned (<span class="self">self</span>) -&gt; Stream &lt; T , W , C , N &gt; { <span class="self">self </span>. map (q ! (| d | d . clone ())) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, K , V1 , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; (K , V1) , W , C , N &gt; { <span class="kw">pub fn </span>join &lt; W2 , V2 &gt; (<span class="self">self </span>, n : Stream &lt; (K , V2) , W2 , C , N &gt;) -&gt; Stream &lt; (K , (V1 , V2)) , W , C , N &gt; <span class="kw">where </span>K : Eq + Hash , { <span class="kw">if </span><span class="self">self </span>. location_kind != n . location_kind { panic ! (<span class="string">"join must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Join (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (n . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>anti_join &lt; W2 &gt; (<span class="self">self </span>, n : Stream &lt; K , W2 , C , N &gt;) -&gt; Stream &lt; (K , V1) , W , C , N &gt; <span class="kw">where </span>K : Eq + Hash , { <span class="kw">if </span><span class="self">self </span>. location_kind != n . location_kind { panic ! (<span class="string">"anti_join must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: AntiJoin (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (n . ir_node . into_inner ()) ,) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, K : Eq + Hash , V , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; (K , V) , Bounded , Tick , N &gt; { <span class="kw">pub fn </span>fold_keyed &lt; A , I : Fn () -&gt; A + <span class="lifetime">'a </span>, F : Fn (&amp; <span class="kw-2">mut </span>A , V) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, I &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; (K , A) , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: FoldKeyed { init : init . splice_fn0 () . into () , acc : comb . splice_fn2_borrow_mut () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>reduce_keyed &lt; F : Fn (&amp; <span class="kw-2">mut </span>V , V) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; (K , V) , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: ReduceKeyed { f : comb . splice_fn2_borrow_mut () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } } <span class="kw">pub fn </span>serialize_bincode &lt; T : Serialize &gt; (is_demux : bool) -&gt; Pipeline { <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span>t_type : syn :: Type = stageleft :: quote_type :: &lt; T &gt; () ; <span class="kw">if </span>is_demux { parse_quote ! { map (| (id , data) : (# root :: ClusterId &lt; <span class="kw">_ </span>&gt;, # t_type) | { (id . raw_id , # root :: runtime_support :: bincode :: serialize ::&lt;# t_type &gt; (&amp; data) . unwrap () . into ()) }) } } <span class="kw">else </span>{ parse_quote ! { map (| data | { # root :: runtime_support :: bincode :: serialize ::&lt;# t_type &gt; (&amp; data) . unwrap () . into () }) } } } <span class="kw">pub fn </span>deserialize_bincode &lt; T : DeserializeOwned &gt; (tagged : <span class="prelude-ty">Option </span>&lt; syn :: Type &gt;) -&gt; Pipeline { <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span>t_type : syn :: Type = stageleft :: quote_type :: &lt; T &gt; () ; <span class="kw">if let </span><span class="prelude-val">Some </span>(c_type) = tagged { parse_quote ! { map (| res | { <span class="kw">let </span>(id , b) = res . unwrap () ; (# root :: ClusterId ::&lt;# c_type &gt;:: from_raw (id) , # root :: runtime_support :: bincode :: deserialize ::&lt;# t_type &gt; (&amp; b) . unwrap ()) }) } } <span class="kw">else </span>{ parse_quote ! { map (| res | { # root :: runtime_support :: bincode :: deserialize ::&lt;# t_type &gt; (&amp; res . unwrap ()) . unwrap () }) } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; T , W , NoTick , N &gt; { <span class="kw">pub fn </span>decouple_process &lt; P2 &gt; (<span class="self">self </span>, other : &amp; Process &lt; <span class="lifetime">'a </span>, P2 &gt; ,) -&gt; Stream &lt; T , Unbounded , NoTick , Process &lt; <span class="lifetime">'a </span>, P2 &gt; &gt; <span class="kw">where </span>N : CanSend &lt; <span class="lifetime">'a </span>, Process &lt; <span class="lifetime">'a </span>, P2 &gt; , In &lt; T &gt; = T , Out &lt; T &gt; = T &gt; , T : Clone + Serialize + DeserializeOwned , { <span class="self">self </span>. send_bincode :: &lt; Process &lt; <span class="lifetime">'a </span>, P2 &gt; , T &gt; (other) } <span class="kw">pub fn </span>decouple_cluster &lt; C2 , Tag &gt; (<span class="self">self </span>, other : &amp; Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; ,) -&gt; Stream &lt; T , Unbounded , NoTick , Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; <span class="kw">where </span>N : CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , In &lt; T &gt; = (ClusterId &lt; C2 &gt; , T) , Out &lt; T &gt; = (Tag , T) &gt; , T : Clone + Serialize + DeserializeOwned , { <span class="kw">let </span>self_node_id = <span class="kw">match </span><span class="self">self </span>. location_kind { LocationId :: Cluster (cluster_id) =&gt; builder :: ClusterSelfId { id : cluster_id , _phantom : PhantomData , } , <span class="kw">_ </span>=&gt; panic ! (<span class="string">"decouple_cluster must be called on a cluster"</span>) , } ; <span class="self">self </span>. map (q ! (<span class="kw">move </span>| b | (self_node_id , b . clone ()))) . send_bincode_interleaved (other) } <span class="kw">pub fn </span>send_bincode &lt; N2 : Location &lt; <span class="lifetime">'a </span>&gt; , CoreType &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; N :: Out &lt; CoreType &gt; , Unbounded , NoTick , N2 &gt; <span class="kw">where </span>N : CanSend &lt; <span class="lifetime">'a </span>, N2 , In &lt; CoreType &gt; = T &gt; , CoreType : Serialize + DeserializeOwned , { <span class="kw">let </span>serialize_pipeline = <span class="prelude-val">Some </span>(serialize_bincode :: &lt; CoreType &gt; (N :: is_demux ())) ; <span class="kw">let </span>deserialize_pipeline = <span class="prelude-val">Some </span>(deserialize_bincode :: &lt; CoreType &gt; (N :: tagged_type ())) ; Stream :: new (other . id () , <span class="self">self </span>. flow_state , HfPlusNode :: Network { from_location : <span class="self">self </span>. location_kind , from_key : <span class="prelude-val">None </span>, to_location : other . id () , to_key : <span class="prelude-val">None </span>, serialize_pipeline , instantiate_fn : DebugInstantiate :: Building () , deserialize_pipeline , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>send_bincode_external &lt; N2 : <span class="lifetime">'a </span>, CoreType &gt; (<span class="self">self </span>, other : &amp; ExternalProcess &lt; N2 &gt; ,) -&gt; ExternalBincodeStream &lt; N :: Out &lt; CoreType &gt; &gt; <span class="kw">where </span>N : CanSend &lt; <span class="lifetime">'a </span>, ExternalProcess &lt; <span class="lifetime">'a </span>, N2 &gt; , In &lt; CoreType &gt; = T , Out &lt; CoreType &gt; = CoreType &gt; , CoreType : Serialize + DeserializeOwned , { <span class="kw">let </span>serialize_pipeline = <span class="prelude-val">Some </span>(serialize_bincode :: &lt; CoreType &gt; (N :: is_demux ())) ; <span class="kw">let </span><span class="kw-2">mut </span>flow_state_borrow = <span class="self">self </span>. flow_state . borrow_mut () ; <span class="kw">let </span>external_key = flow_state_borrow . next_external_out ; flow_state_borrow . next_external_out += <span class="number">1 </span>; <span class="kw">let </span>leaves = flow_state_borrow . leaves . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled()"</span>) ; <span class="kw">let </span>dummy_f : syn :: Expr = syn :: parse_quote ! (()) ; leaves . push (HfPlusLeaf :: ForEach { f : dummy_f . into () , input : Box :: new (HfPlusNode :: Network { from_location : <span class="self">self </span>. location_kind , from_key : <span class="prelude-val">None </span>, to_location : other . id () , to_key : <span class="prelude-val">Some </span>(external_key) , serialize_pipeline , instantiate_fn : DebugInstantiate :: Building () , deserialize_pipeline : <span class="prelude-val">None </span>, input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) , }) ; ExternalBincodeStream { process_id : other . id , port_id : external_key , _phantom : PhantomData , } } <span class="kw">pub fn </span>send_bytes &lt; N2 : Location &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; N :: Out &lt; Bytes &gt; , Unbounded , NoTick , N2 &gt; <span class="kw">where </span>N : CanSend &lt; <span class="lifetime">'a </span>, N2 , In &lt; Bytes &gt; = T &gt; , { <span class="kw">let </span>root = get_this_crate () ; Stream :: new (other . id () , <span class="self">self </span>. flow_state , HfPlusNode :: Network { from_location : <span class="self">self </span>. location_kind , from_key : <span class="prelude-val">None </span>, to_location : other . id () , to_key : <span class="prelude-val">None </span>, serialize_pipeline : <span class="prelude-val">None </span>, instantiate_fn : DebugInstantiate :: Building () , deserialize_pipeline : <span class="kw">if let </span><span class="prelude-val">Some </span>(c_type) = N :: tagged_type () { <span class="prelude-val">Some </span>(parse_quote ! (map (| (id , b) | (# root :: ClusterId &lt;# c_type &gt;:: from_raw (id) , b . unwrap () . freeze ()))) ,) } <span class="kw">else </span>{ <span class="prelude-val">Some </span>(parse_quote ! (map (| b | b . unwrap () . freeze ()))) } , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>send_bytes_external &lt; N2 : <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, other : &amp; ExternalProcess &lt; N2 &gt;) -&gt; ExternalBytesPort <span class="kw">where </span>N : CanSend &lt; <span class="lifetime">'a </span>, ExternalProcess &lt; <span class="lifetime">'a </span>, N2 &gt; , In &lt; Bytes &gt; = T , Out &lt; Bytes &gt; = Bytes &gt; , { <span class="kw">let </span><span class="kw-2">mut </span>flow_state_borrow = <span class="self">self </span>. flow_state . borrow_mut () ; <span class="kw">let </span>external_key = flow_state_borrow . next_external_out ; flow_state_borrow . next_external_out += <span class="number">1 </span>; <span class="kw">let </span>leaves = flow_state_borrow . leaves . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled()"</span>) ; <span class="kw">let </span>dummy_f : syn :: Expr = syn :: parse_quote ! (()) ; leaves . push (HfPlusLeaf :: ForEach { f : dummy_f . into () , input : Box :: new (HfPlusNode :: Network { from_location : <span class="self">self </span>. location_kind , from_key : <span class="prelude-val">None </span>, to_location : other . id () , to_key : <span class="prelude-val">Some </span>(external_key) , serialize_pipeline : <span class="prelude-val">None </span>, instantiate_fn : DebugInstantiate :: Building () , deserialize_pipeline : <span class="prelude-val">None </span>, input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) , }) ; ExternalBytesPort { process_id : other . id , port_id : external_key , } } <span class="kw">pub fn </span>send_bincode_interleaved &lt; N2 : Location &lt; <span class="lifetime">'a </span>&gt; , Tag , CoreType &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; CoreType , Unbounded , NoTick , N2 &gt; <span class="kw">where </span>N : CanSend &lt; <span class="lifetime">'a </span>, N2 , In &lt; CoreType &gt; = T , Out &lt; CoreType &gt; = (Tag , CoreType) &gt; , CoreType : Serialize + DeserializeOwned , { <span class="self">self </span>. send_bincode :: &lt; N2 , CoreType &gt; (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } <span class="kw">pub fn </span>send_bytes_interleaved &lt; N2 : Location &lt; <span class="lifetime">'a </span>&gt; , Tag &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; Bytes , Unbounded , NoTick , N2 &gt; <span class="kw">where </span>N : CanSend &lt; <span class="lifetime">'a </span>, N2 , In &lt; Bytes &gt; = T , Out &lt; Bytes &gt; = (Tag , Bytes) &gt; , { <span class="self">self </span>. send_bytes :: &lt; N2 &gt; (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } <span class="kw">pub fn </span>broadcast_bincode &lt; C2 &gt; (<span class="self">self </span>, other : &amp; Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; ,) -&gt; Stream &lt; N :: Out &lt; T &gt; , Unbounded , NoTick , Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; <span class="kw">where </span>N : CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , In &lt; T &gt; = (ClusterId &lt; C2 &gt; , T) &gt; , T : Clone + Serialize + DeserializeOwned , { <span class="kw">let </span>ids = other . members () ; <span class="self">self </span>. flat_map (q ! (| b | ids . iter () . map (<span class="kw">move </span>| id | (:: std :: clone :: Clone :: clone (id) , :: std :: clone :: Clone :: clone (&amp; b))))) . send_bincode (other) } <span class="kw">pub fn </span>broadcast_bincode_interleaved &lt; C2 , Tag &gt; (<span class="self">self </span>, other : &amp; Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; ,) -&gt; Stream &lt; T , Unbounded , NoTick , Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; <span class="kw">where </span>N : CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , In &lt; T &gt; = (ClusterId &lt; C2 &gt; , T) , Out &lt; T &gt; = (Tag , T) &gt; + <span class="lifetime">'a </span>, T : Clone + Serialize + DeserializeOwned , { <span class="self">self </span>. broadcast_bincode (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } <span class="kw">pub fn </span>broadcast_bytes &lt; C2 &gt; (<span class="self">self </span>, other : &amp; Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; ,) -&gt; Stream &lt; N :: Out &lt; Bytes &gt; , Unbounded , NoTick , Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; <span class="kw">where </span>N : CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , In &lt; Bytes &gt; = (ClusterId &lt; C2 &gt; , T) &gt; + <span class="lifetime">'a </span>, T : Clone , { <span class="kw">let </span>ids = other . members () ; <span class="self">self </span>. flat_map (q ! (| b | ids . iter () . map (<span class="kw">move </span>| id | (:: std :: clone :: Clone :: clone (id) , :: std :: clone :: Clone :: clone (&amp; b))))) . send_bytes (other) } <span class="kw">pub fn </span>broadcast_bytes_interleaved &lt; C2 , Tag &gt; (<span class="self">self </span>, other : &amp; Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; ,) -&gt; Stream &lt; Bytes , Unbounded , NoTick , Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; <span class="kw">where </span>N : CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , In &lt; Bytes &gt; = (ClusterId &lt; C2 &gt; , T) , Out &lt; Bytes &gt; = (Tag , Bytes) &gt; + <span class="lifetime">'a </span>, T : Clone , { <span class="self">self </span>. broadcast_bytes (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } } # [cfg (stageleft_macro)] <span class="kw">pub mod </span>tests { <span class="kw">pub use </span>std :: sync :: Arc ; <span class="kw">pub use </span>hydro_deploy :: { Deployment , Host } ; <span class="kw">pub use </span>hydroflow :: futures :: StreamExt ; <span class="kw">pub use </span>serde :: { Deserialize , Serialize } ; <span class="kw">pub use </span>stageleft :: q ; <span class="kw">pub use crate </span>:: deploy :: TrybuildHost ; <span class="kw">pub use crate </span>:: location :: Location ; <span class="kw">pub use crate </span>:: FlowBuilder ; <span class="kw">pub struct </span>P1 { } <span class="kw">pub struct </span>P2 { } # [derive (Serialize , Deserialize , Debug)] <span class="kw">pub struct </span>SendOverNetwork { <span class="kw">pub </span>n : u32 , } # [tokio :: test] <span class="kw">pub async fn </span>first_ten_distributed () { <span class="kw">let </span><span class="kw-2">mut </span>deployment = Deployment :: new () ; <span class="kw">let </span>flow = FlowBuilder :: new () ; <span class="kw">let </span>first_node = flow . process :: &lt; P1 &gt; () ; <span class="kw">let </span>second_node = flow . process :: &lt; P2 &gt; () ; <span class="kw">let </span>external = flow . external_process :: &lt; P2 &gt; () ; <span class="kw">let </span>numbers = first_node . source_iter (q ! (<span class="number">0 </span>.. <span class="number">10</span>)) ; <span class="kw">let </span>out_port = numbers . map (q ! (| n | SendOverNetwork { n })) . send_bincode (&amp; second_node) . send_bincode_external (&amp; external) ; <span class="kw">let </span>nodes = flow . with_default_optimize () . with_process (&amp; first_node , TrybuildHost :: new (deployment . Localhost ())) . with_process (&amp; second_node , TrybuildHost :: new (deployment . Localhost ())) . with_external (&amp; external , deployment . Localhost () <span class="kw">as </span>Arc &lt; <span class="kw">dyn </span>Host &gt;) . deploy (&amp; <span class="kw-2">mut </span>deployment) ; deployment . deploy () . <span class="kw">await </span>. unwrap () ; <span class="kw">let </span><span class="kw-2">mut </span>external_out = nodes . connect_source_bincode (out_port) . <span class="kw">await </span>; deployment . start () . <span class="kw">await </span>. unwrap () ; <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. <span class="number">10 </span>{ assert_eq ! (external_out . next () . <span class="kw">await </span>. unwrap () . n , i) ; } } } } <span class="kw">pub use </span>stream :: { Bounded , NoTick , Stream , Tick , Unbounded } ; <span class="kw">pub mod </span>singleton { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: ops :: Deref ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>stageleft :: { q , IntoQuotedMut , Quoted } ; <span class="kw">pub use crate </span>:: builder :: FlowState ; <span class="kw">pub use crate </span>:: cycle :: { CycleCollection , CycleCollectionWithInitial , CycleComplete } ; <span class="kw">pub use crate </span>:: ir :: { HfPlusLeaf , HfPlusNode , HfPlusSource , TeeNode } ; <span class="kw">pub use crate </span>:: location :: { Location , LocationId } ; <span class="kw">pub use crate </span>:: stream :: { Bounded , NoTick , Tick , Unbounded } ; <span class="kw">pub use crate </span>:: Stream ; <span class="kw">pub use crate </span>:: singleton :: CrossResult ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , U : Clone , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CrossResult &lt; <span class="lifetime">'a </span>, Singleton &lt; U , W , C , N &gt; &gt; <span class="kw">for </span>Singleton &lt; T , W , C , N &gt; { <span class="kw">type </span>Out = Singleton &lt; (T , U) , W , C , N &gt; ; <span class="kw">fn </span>other_location (other : &amp; Singleton &lt; U , W , C , N &gt;) -&gt; LocationId { other . location_kind } <span class="kw">fn </span>other_ir_node (other : Singleton &lt; U , W , C , N &gt;) -&gt; HfPlusNode { other . ir_node . into_inner () } <span class="kw">fn </span>make (location_kind : LocationId , flow_state : FlowState , ir_node : HfPlusNode) -&gt; <span class="self">Self </span>:: Out { Singleton :: new (location_kind , flow_state , ir_node) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , U : Clone , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CrossResult &lt; <span class="lifetime">'a </span>, Optional &lt; U , W , C , N &gt; &gt; <span class="kw">for </span>Singleton &lt; T , W , C , N &gt; { <span class="kw">type </span>Out = Optional &lt; (T , U) , W , C , N &gt; ; <span class="kw">fn </span>other_location (other : &amp; Optional &lt; U , W , C , N &gt;) -&gt; LocationId { other . location_kind } <span class="kw">fn </span>other_ir_node (other : Optional &lt; U , W , C , N &gt;) -&gt; HfPlusNode { other . ir_node . into_inner () } <span class="kw">fn </span>make (location_kind : LocationId , flow_state : FlowState , ir_node : HfPlusNode) -&gt; <span class="self">Self </span>:: Out { Optional :: new (location_kind , flow_state , ir_node) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , U : Clone , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CrossResult &lt; <span class="lifetime">'a </span>, Optional &lt; U , W , C , N &gt; &gt; <span class="kw">for </span>Optional &lt; T , W , C , N &gt; { <span class="kw">type </span>Out = Optional &lt; (T , U) , W , C , N &gt; ; <span class="kw">fn </span>other_location (other : &amp; Optional &lt; U , W , C , N &gt;) -&gt; LocationId { other . location_kind } <span class="kw">fn </span>other_ir_node (other : Optional &lt; U , W , C , N &gt;) -&gt; HfPlusNode { other . ir_node . into_inner () } <span class="kw">fn </span>make (location_kind : LocationId , flow_state : FlowState , ir_node : HfPlusNode) -&gt; <span class="self">Self </span>:: Out { Optional :: new (location_kind , flow_state , ir_node) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , U : Clone , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CrossResult &lt; <span class="lifetime">'a </span>, Singleton &lt; U , W , C , N &gt; &gt; <span class="kw">for </span>Optional &lt; T , W , C , N &gt; { <span class="kw">type </span>Out = Optional &lt; (T , U) , W , C , N &gt; ; <span class="kw">fn </span>other_location (other : &amp; Singleton &lt; U , W , C , N &gt;) -&gt; LocationId { other . location_kind } <span class="kw">fn </span>other_ir_node (other : Singleton &lt; U , W , C , N &gt;) -&gt; HfPlusNode { other . ir_node . into_inner () } <span class="kw">fn </span>make (location_kind : LocationId , flow_state : FlowState , ir_node : HfPlusNode) -&gt; <span class="self">Self </span>:: Out { Optional :: new (location_kind , flow_state , ir_node) } } <span class="kw">pub use crate </span>:: singleton :: Singleton ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Singleton &lt; T , W , C , N &gt; { <span class="kw">pub </span>(<span class="kw">crate</span>) <span class="kw">fn </span>new (location_kind : LocationId , flow_state : FlowState , ir_node : HfPlusNode ,) -&gt; <span class="self">Self </span>{ Singleton { location_kind , flow_state , ir_node : RefCell :: new (ir_node) , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; From &lt; Singleton &lt; T , Bounded , C , N &gt; &gt; <span class="kw">for </span>Singleton &lt; T , Unbounded , C , N &gt; { <span class="kw">fn </span>from (singleton : Singleton &lt; T , Bounded , C , N &gt;) -&gt; <span class="self">Self </span>{ Singleton :: new (singleton . location_kind , singleton . flow_state , singleton . ir_node . into_inner () ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleComplete &lt; <span class="lifetime">'a </span>, Tick &gt; <span class="kw">for </span>Singleton &lt; T , Bounded , Tick , N &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident) { <span class="self">self </span>. flow_state . borrow_mut () . leaves . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled."</span>) . push (HfPlusLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleCollectionWithInitial &lt; <span class="lifetime">'a </span>, Tick &gt; <span class="kw">for </span>Singleton &lt; T , Bounded , Tick , N &gt; { <span class="kw">type </span>Location = N ; <span class="kw">fn </span>create_source (ident : syn :: Ident , flow_state : FlowState , initial : <span class="self">Self </span>, l : LocationId ,) -&gt; <span class="self">Self </span>{ Singleton :: new (l , flow_state , HfPlusNode :: Union (Box :: new (HfPlusNode :: CycleSource { ident , location_kind : l , }) , initial . ir_node . into_inner () . into () ,) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Clone , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Clone <span class="kw">for </span>Singleton &lt; T , W , C , N &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ <span class="kw">if </span>! matches ! (<span class="self">self </span>. ir_node . borrow () . deref () , HfPlusNode :: Tee { .. }) { <span class="kw">let </span>orig_ir_node = <span class="self">self </span>. ir_node . replace (HfPlusNode :: Placeholder) ; * <span class="self">self </span>. ir_node . borrow_mut () = HfPlusNode :: Tee { inner : TeeNode (Rc :: new (RefCell :: new (orig_ir_node))) , } ; } <span class="kw">if let </span>HfPlusNode :: Tee { inner } = <span class="self">self </span>. ir_node . borrow () . deref () { Singleton { location_kind : <span class="self">self </span>. location_kind , flow_state : <span class="self">self </span>. flow_state . clone () , ir_node : HfPlusNode :: Tee { inner : TeeNode (inner . <span class="number">0 </span>. clone ()) , } . into () , _phantom : PhantomData , } } <span class="kw">else </span>{ unreachable ! () } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Singleton &lt; T , W , C , N &gt; { <span class="kw">pub fn </span>map &lt; U , F : Fn (T) -&gt; U + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt;) -&gt; Singleton &lt; U , W , C , N &gt; { Singleton :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Map { f : f . splice_fn1 () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>flat_map &lt; U , I : IntoIterator &lt; Item = U &gt; , F : Fn (T) -&gt; I + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; U , W , C , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: FlatMap { f : f . splice_fn1 () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter &lt; F : Fn (&amp; T) -&gt; bool + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Optional &lt; T , W , C , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Filter { f : f . splice_fn1_borrow () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter_map &lt; U , F : Fn (T) -&gt; <span class="prelude-ty">Option </span>&lt; U &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Optional &lt; U , W , C , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: FilterMap { f : f . splice_fn1 () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Singleton &lt; T , Bounded , Tick , N &gt; { <span class="kw">pub fn </span>cross_singleton &lt; Other &gt; (<span class="self">self </span>, other : Other) -&gt; &lt; <span class="self">Self </span><span class="kw">as </span>CrossResult &lt; <span class="lifetime">'a </span>, Other &gt; &gt; :: Out <span class="kw">where </span><span class="self">Self </span>: CrossResult &lt; <span class="lifetime">'a </span>, Other &gt; , { <span class="kw">if </span><span class="self">self </span>. location_kind != <span class="self">Self </span>:: other_location (&amp; other) { panic ! (<span class="string">"cross_singleton must be called on streams on the same node"</span>) ; } <span class="self">Self </span>:: make (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: CrossSingleton (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (<span class="self">Self </span>:: other_ir_node (other)) ,) ,) } <span class="kw">pub fn </span>continue_if &lt; U &gt; (<span class="self">self </span>, signal : Optional &lt; U , Bounded , Tick , N &gt; ,) -&gt; Optional &lt; T , Bounded , Tick , N &gt; { <span class="self">self </span>. cross_singleton (signal . map (q ! (| _u | ()))) . map (q ! (| (d , _signal) | d)) } <span class="kw">pub fn </span>continue_unless &lt; U &gt; (<span class="self">self </span>, other : Optional &lt; U , Bounded , Tick , N &gt; ,) -&gt; Optional &lt; T , Bounded , Tick , N &gt; { <span class="self">self </span>. continue_if (other . into_stream () . count () . filter (q ! (| c | * c == <span class="number">0</span>))) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Singleton &lt; T , Bounded , Tick , N &gt; { <span class="kw">pub fn </span>all_ticks (<span class="self">self</span>) -&gt; Stream &lt; T , Unbounded , NoTick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>latest (<span class="self">self</span>) -&gt; Singleton &lt; T , Unbounded , NoTick , N &gt; { Singleton :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>defer_tick (<span class="self">self</span>) -&gt; Singleton &lt; T , Bounded , Tick , N &gt; { Singleton :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: DeferTick (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>persist (<span class="self">self</span>) -&gt; Stream &lt; T , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>delta (<span class="self">self</span>) -&gt; Optional &lt; T , Bounded , Tick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Delta (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , B , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Singleton &lt; T , B , NoTick , N &gt; { <span class="kw">pub fn </span>latest_tick (<span class="self">self</span>) -&gt; Singleton &lt; T , Bounded , Tick , N &gt; { Singleton :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>sample_every (<span class="self">self </span>, duration : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, std :: time :: Duration &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Stream &lt; T , Unbounded , NoTick , N &gt; { <span class="kw">let </span>interval = duration . splice_typed () ; <span class="kw">let </span>samples = Stream :: &lt; () , Bounded , Tick , N &gt; :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state . clone () , HfPlusNode :: Source { source : HfPlusSource :: Interval (interval . into ()) , location_kind : <span class="self">self </span>. location_kind , } ,) ; <span class="self">self </span>. latest_tick () . continue_if (samples . first ()) . latest () . tick_samples () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Singleton &lt; T , Unbounded , NoTick , N &gt; { <span class="kw">pub fn </span>cross_singleton &lt; Other &gt; (<span class="self">self </span>, other : Other) -&gt; &lt; <span class="self">Self </span><span class="kw">as </span>CrossResult &lt; <span class="lifetime">'a </span>, Other &gt; &gt; :: Out <span class="kw">where </span><span class="self">Self </span>: CrossResult &lt; <span class="lifetime">'a </span>, Other &gt; , { <span class="kw">if </span><span class="self">self </span>. location_kind != <span class="self">Self </span>:: other_location (&amp; other) { panic ! (<span class="string">"cross_singleton must be called on streams on the same node"</span>) ; } <span class="self">Self </span>:: make (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Persist (Box :: new (HfPlusNode :: CrossSingleton (Box :: new (HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , Box :: new (HfPlusNode :: Unpersist (Box :: new (<span class="self">Self </span>:: other_ir_node (other)))) ,))) ,) } } <span class="kw">pub use crate </span>:: singleton :: Optional ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Optional &lt; T , W , C , N &gt; { <span class="kw">pub </span>(<span class="kw">crate</span>) <span class="kw">fn </span>new (location_kind : LocationId , flow_state : FlowState , ir_node : HfPlusNode ,) -&gt; <span class="self">Self </span>{ Optional { location_kind , flow_state , ir_node : RefCell :: new (ir_node) , _phantom : PhantomData , } } <span class="kw">pub fn </span>some (singleton : Singleton &lt; T , W , C , N &gt;) -&gt; <span class="self">Self </span>{ Optional :: new (singleton . location_kind , singleton . flow_state , singleton . ir_node . into_inner () ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleComplete &lt; <span class="lifetime">'a </span>, Tick &gt; <span class="kw">for </span>Optional &lt; T , Bounded , Tick , N &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident) { <span class="kw">let </span>me = <span class="self">self </span>. defer_tick () ; me . flow_state . borrow_mut () . leaves . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled."</span>) . push (HfPlusLeaf :: CycleSink { ident , location_kind : me . location_kind , input : Box :: new (me . ir_node . into_inner ()) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleCollection &lt; <span class="lifetime">'a </span>, Tick &gt; <span class="kw">for </span>Optional &lt; T , Bounded , Tick , N &gt; { <span class="kw">type </span>Location = N ; <span class="kw">fn </span>create_source (ident : syn :: Ident , flow_state : FlowState , l : LocationId) -&gt; <span class="self">Self </span>{ Optional :: new (l , flow_state , HfPlusNode :: CycleSource { ident , location_kind : l , } ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleComplete &lt; <span class="lifetime">'a </span>, NoTick &gt; <span class="kw">for </span>Optional &lt; T , W , NoTick , N &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident) { <span class="self">self </span>. flow_state . borrow_mut () . leaves . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled."</span>) . push (HfPlusLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind , input : Box :: new (HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleCollection &lt; <span class="lifetime">'a </span>, NoTick &gt; <span class="kw">for </span>Optional &lt; T , W , NoTick , N &gt; { <span class="kw">type </span>Location = N ; <span class="kw">fn </span>create_source (ident : syn :: Ident , flow_state : FlowState , l : LocationId) -&gt; <span class="self">Self </span>{ Optional :: new (l , flow_state , HfPlusNode :: Persist (Box :: new (HfPlusNode :: CycleSource { ident , location_kind : l , })) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; From &lt; Singleton &lt; T , W , C , N &gt; &gt; <span class="kw">for </span>Optional &lt; T , W , C , N &gt; { <span class="kw">fn </span>from (singleton : Singleton &lt; T , W , C , N &gt;) -&gt; <span class="self">Self </span>{ Optional :: some (singleton) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Clone , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Clone <span class="kw">for </span>Optional &lt; T , W , C , N &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ <span class="kw">if </span>! matches ! (<span class="self">self </span>. ir_node . borrow () . deref () , HfPlusNode :: Tee { .. }) { <span class="kw">let </span>orig_ir_node = <span class="self">self </span>. ir_node . replace (HfPlusNode :: Placeholder) ; * <span class="self">self </span>. ir_node . borrow_mut () = HfPlusNode :: Tee { inner : TeeNode (Rc :: new (RefCell :: new (orig_ir_node))) , } ; } <span class="kw">if let </span>HfPlusNode :: Tee { inner } = <span class="self">self </span>. ir_node . borrow () . deref () { Optional { location_kind : <span class="self">self </span>. location_kind , flow_state : <span class="self">self </span>. flow_state . clone () , ir_node : HfPlusNode :: Tee { inner : TeeNode (inner . <span class="number">0 </span>. clone ()) , } . into () , _phantom : PhantomData , } } <span class="kw">else </span>{ unreachable ! () } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , C , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Optional &lt; T , W , C , N &gt; { <span class="kw">pub fn </span>map &lt; U , F : Fn (T) -&gt; U + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt;) -&gt; Optional &lt; U , W , C , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Map { f : f . splice_fn1 () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>flat_map &lt; U , I : IntoIterator &lt; Item = U &gt; , F : Fn (T) -&gt; I + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; U , W , C , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: FlatMap { f : f . splice_fn1 () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter &lt; F : Fn (&amp; T) -&gt; bool + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Optional &lt; T , W , C , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Filter { f : f . splice_fn1_borrow () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter_map &lt; U , F : Fn (T) -&gt; <span class="prelude-ty">Option </span>&lt; U &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Optional &lt; U , W , C , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: FilterMap { f : f . splice_fn1 () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Optional &lt; T , Bounded , Tick , N &gt; { <span class="kw">pub fn </span>into_stream (<span class="self">self</span>) -&gt; Stream &lt; T , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , <span class="self">self </span>. ir_node . into_inner () ,) } <span class="kw">pub fn </span>cross_singleton &lt; O &gt; (<span class="self">self </span>, other : <span class="kw">impl </span>Into &lt; Optional &lt; O , Bounded , Tick , N &gt; &gt; ,) -&gt; Optional &lt; (T , O) , Bounded , Tick , N &gt; <span class="kw">where </span>O : Clone , { <span class="kw">let </span>other : Optional &lt; O , Bounded , Tick , N &gt; = other . into () ; <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"cross_singleton must be called on streams on the same node"</span>) ; } Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: CrossSingleton (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>continue_if &lt; U &gt; (<span class="self">self </span>, signal : Optional &lt; U , Bounded , Tick , N &gt; ,) -&gt; Optional &lt; T , Bounded , Tick , N &gt; { <span class="self">self </span>. cross_singleton (signal . map (q ! (| _u | ()))) . map (q ! (| (d , _signal) | d)) } <span class="kw">pub fn </span>continue_unless &lt; U &gt; (<span class="self">self </span>, other : Optional &lt; U , Bounded , Tick , N &gt; ,) -&gt; Optional &lt; T , Bounded , Tick , N &gt; { <span class="self">self </span>. continue_if (other . into_stream () . count () . filter (q ! (| c | * c == <span class="number">0</span>))) } <span class="kw">pub fn </span>union (<span class="self">self </span>, other : Optional &lt; T , Bounded , Tick , N &gt;) -&gt; Optional &lt; T , Bounded , Tick , N &gt; { <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"union must be called on streams on the same node"</span>) ; } Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Union (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>unwrap_or (<span class="self">self </span>, other : Singleton &lt; T , Bounded , Tick , N &gt; ,) -&gt; Singleton &lt; T , Bounded , Tick , N &gt; { <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"or_else must be called on streams on the same node"</span>) ; } Singleton :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Union (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Optional &lt; T , Bounded , Tick , N &gt; { <span class="kw">pub fn </span>all_ticks (<span class="self">self</span>) -&gt; Stream &lt; T , Unbounded , NoTick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>latest (<span class="self">self</span>) -&gt; Optional &lt; T , Unbounded , NoTick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>defer_tick (<span class="self">self</span>) -&gt; Optional &lt; T , Bounded , Tick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: DeferTick (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>persist (<span class="self">self</span>) -&gt; Stream &lt; T , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>delta (<span class="self">self</span>) -&gt; Optional &lt; T , Bounded , Tick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Delta (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , B , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Optional &lt; T , B , NoTick , N &gt; { <span class="kw">pub fn </span>latest_tick (<span class="self">self</span>) -&gt; Optional &lt; T , Bounded , Tick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state , HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>tick_samples (<span class="self">self</span>) -&gt; Stream &lt; T , Unbounded , NoTick , N &gt; { <span class="self">self </span>. latest_tick () . all_ticks () } <span class="kw">pub fn </span>sample_every (<span class="self">self </span>, duration : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, std :: time :: Duration &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Stream &lt; T , Unbounded , NoTick , N &gt; { <span class="kw">let </span>interval = duration . splice_typed () ; <span class="kw">let </span>samples = Stream :: &lt; () , Bounded , Tick , N &gt; :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. flow_state . clone () , HfPlusNode :: Source { source : HfPlusSource :: Interval (interval . into ()) , location_kind : <span class="self">self </span>. location_kind , } ,) ; <span class="self">self </span>. latest_tick () . continue_if (samples . first ()) . latest () . tick_samples () } <span class="kw">pub fn </span>unwrap_or (<span class="self">self </span>, other : <span class="kw">impl </span>Into &lt; Singleton &lt; T , Unbounded , NoTick , N &gt; &gt; ,) -&gt; Singleton &lt; T , Unbounded , NoTick , N &gt; { <span class="kw">let </span>other = other . into () ; <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"or_else must be called on streams on the same node"</span>) ; } <span class="self">self </span>. latest_tick () . unwrap_or (other . latest_tick ()) . latest () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Optional &lt; T , Unbounded , NoTick , N &gt; { <span class="kw">pub fn </span>cross_singleton &lt; O &gt; (<span class="self">self </span>, other : <span class="kw">impl </span>Into &lt; Optional &lt; O , Unbounded , NoTick , N &gt; &gt; ,) -&gt; Optional &lt; (T , O) , Unbounded , NoTick , N &gt; <span class="kw">where </span>O : Clone , { <span class="kw">let </span>other : Optional &lt; O , Unbounded , NoTick , N &gt; = other . into () ; <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"cross_singleton must be called on streams on the same node"</span>) ; } <span class="self">self </span>. latest_tick () . cross_singleton (other . latest_tick ()) . latest () } } } <span class="kw">pub use </span>singleton :: { Optional , Singleton } ; <span class="kw">pub mod </span>location { <span class="kw">pub use </span>std :: fmt :: { Debug , Display } ; <span class="kw">pub use </span>std :: hash :: Hash ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: time :: Duration ; <span class="kw">pub use </span>hydroflow :: bytes :: Bytes ; <span class="kw">pub use </span>hydroflow :: futures :: stream :: Stream <span class="kw">as </span>FuturesStream ; <span class="kw">pub use </span>hydroflow :: { tokio , tokio_stream } ; <span class="kw">pub use </span>proc_macro2 :: Span ; <span class="kw">pub use </span>serde :: de :: DeserializeOwned ; <span class="kw">pub use </span>serde :: { Deserialize , Serialize } ; <span class="kw">pub use </span>stageleft :: { q , quote_type , Quoted } ; <span class="kw">pub use super </span>:: builder :: { ClusterIds , ClusterSelfId , FlowState } ; <span class="kw">pub use crate </span>:: cycle :: { CycleCollection , CycleCollectionWithInitial } ; <span class="kw">pub use crate </span>:: ir :: { HfPlusNode , HfPlusSource } ; <span class="kw">pub use crate </span>:: { Bounded , HfCycle , NoTick , Optional , Singleton , Stream , Tick , Unbounded } ; <span class="kw">pub use crate </span>:: location :: LocationId ; <span class="kw">pub use crate </span>:: location :: Location ; <span class="kw">pub use crate </span>:: location :: ExternalBytesPort ; <span class="kw">pub use crate </span>:: location :: ExternalBincodeSink ; <span class="kw">pub use crate </span>:: location :: ExternalBincodeStream ; <span class="kw">pub use crate </span>:: location :: ExternalProcess ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, P &gt; Clone <span class="kw">for </span>ExternalProcess &lt; <span class="lifetime">'a </span>, P &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ ExternalProcess { id : <span class="self">self </span>. id , flow_state : <span class="self">self </span>. flow_state . clone () , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, P &gt; Location &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>ExternalProcess &lt; <span class="lifetime">'a </span>, P &gt; { <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; LocationId { LocationId :: ExternalProcess (<span class="self">self </span>. id) } <span class="kw">fn </span>flow_state (&amp; <span class="self">self</span>) -&gt; &amp; FlowState { &amp; <span class="self">self </span>. flow_state } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, P &gt; ExternalProcess &lt; <span class="lifetime">'a </span>, P &gt; { <span class="kw">pub fn </span>source_external_bytes &lt; L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; (&amp; <span class="self">self </span>, to : &amp; L ,) -&gt; (ExternalBytesPort , Stream &lt; Bytes , Unbounded , NoTick , L &gt;) { <span class="kw">let </span>next_external_port_id = { <span class="kw">let </span><span class="kw-2">mut </span>flow_state = <span class="self">self </span>. flow_state . borrow_mut () ; <span class="kw">let </span>id = flow_state . next_external_out ; flow_state . next_external_out += <span class="number">1 </span>; id } ; (ExternalBytesPort { process_id : <span class="self">self </span>. id , port_id : next_external_port_id , } , Stream :: new (to . id () , <span class="self">self </span>. flow_state () . clone () , HfPlusNode :: Persist (Box :: new (HfPlusNode :: Network { from_location : LocationId :: ExternalProcess (<span class="self">self </span>. id) , from_key : <span class="prelude-val">Some </span>(next_external_port_id) , to_location : to . id () , to_key : <span class="prelude-val">None </span>, serialize_pipeline : <span class="prelude-val">None </span>, instantiate_fn : <span class="kw">crate </span>:: ir :: DebugInstantiate :: Building () , deserialize_pipeline : <span class="prelude-val">Some </span>(syn :: parse_quote ! (map (| b | b . unwrap () . freeze ()))) , input : Box :: new (HfPlusNode :: Source { source : HfPlusSource :: ExternalNetwork () , location_kind : LocationId :: ExternalProcess (<span class="self">self </span>. id) , }) , })) ,) ,) } <span class="kw">pub fn </span>source_external_bincode &lt; L : Location &lt; <span class="lifetime">'a </span>&gt; , T : Serialize + DeserializeOwned &gt; (&amp; <span class="self">self </span>, to : &amp; L ,) -&gt; (ExternalBincodeSink &lt; T &gt; , Stream &lt; T , Unbounded , NoTick , L &gt;) { <span class="kw">let </span>next_external_port_id = { <span class="kw">let </span><span class="kw-2">mut </span>flow_state = <span class="self">self </span>. flow_state . borrow_mut () ; <span class="kw">let </span>id = flow_state . next_external_out ; flow_state . next_external_out += <span class="number">1 </span>; id } ; (ExternalBincodeSink { process_id : <span class="self">self </span>. id , port_id : next_external_port_id , _phantom : PhantomData , } , Stream :: new (to . id () , <span class="self">self </span>. flow_state () . clone () , HfPlusNode :: Persist (Box :: new (HfPlusNode :: Network { from_location : LocationId :: ExternalProcess (<span class="self">self </span>. id) , from_key : <span class="prelude-val">Some </span>(next_external_port_id) , to_location : to . id () , to_key : <span class="prelude-val">None </span>, serialize_pipeline : <span class="prelude-val">None </span>, instantiate_fn : <span class="kw">crate </span>:: ir :: DebugInstantiate :: Building () , deserialize_pipeline : <span class="prelude-val">Some </span>(<span class="kw">crate </span>:: stream :: deserialize_bincode :: &lt; T &gt; (<span class="prelude-val">None</span>)) , input : Box :: new (HfPlusNode :: Source { source : HfPlusSource :: ExternalNetwork () , location_kind : LocationId :: ExternalProcess (<span class="self">self </span>. id) , }) , })) ,) ,) } } <span class="kw">pub use crate </span>:: location :: Process ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, P &gt; Clone <span class="kw">for </span>Process &lt; <span class="lifetime">'a </span>, P &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ Process { id : <span class="self">self </span>. id , flow_state : <span class="self">self </span>. flow_state . clone () , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, P &gt; Location &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Process &lt; <span class="lifetime">'a </span>, P &gt; { <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; LocationId { LocationId :: Process (<span class="self">self </span>. id) } <span class="kw">fn </span>flow_state (&amp; <span class="self">self</span>) -&gt; &amp; FlowState { &amp; <span class="self">self </span>. flow_state } } <span class="kw">pub use crate </span>:: location :: ClusterId ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Debug <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"ClusterId::&lt;{}&gt;({})" </span>, std :: any :: type_name ::&lt; C &gt; () , <span class="self">self </span>. raw_id) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Display <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"ClusterId::&lt;{}&gt;({})" </span>, std :: any :: type_name ::&lt; C &gt; () , <span class="self">self </span>. raw_id) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Clone <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ * <span class="self">self </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Copy <span class="kw">for </span>ClusterId &lt; C &gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Serialize <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>serialize &lt; S &gt; (&amp; <span class="self">self </span>, serializer : S) -&gt; <span class="prelude-ty">Result </span>&lt; S :: <span class="prelude-val">Ok </span>, S :: Error &gt; <span class="kw">where </span>S : serde :: ser :: Serializer , { <span class="self">self </span>. raw_id . serialize (serializer) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'de </span>, C &gt; Deserialize &lt; <span class="lifetime">'de </span>&gt; <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>deserialize &lt; D &gt; (deserializer : D) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, D :: Error &gt; <span class="kw">where </span>D : serde :: de :: Deserializer &lt; <span class="lifetime">'de </span>&gt; , { u32 :: deserialize (deserializer) . map (| id | ClusterId { raw_id : id , _phantom : PhantomData , }) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; PartialEq <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>eq (&amp; <span class="self">self </span>, other : &amp; <span class="self">Self</span>) -&gt; bool { <span class="self">self </span>. raw_id == other . raw_id } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Eq <span class="kw">for </span>ClusterId &lt; C &gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; PartialOrd <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>partial_cmp (&amp; <span class="self">self </span>, other : &amp; <span class="self">Self</span>) -&gt; <span class="prelude-ty">Option </span>&lt; std :: cmp :: Ordering &gt; { <span class="prelude-val">Some </span>(<span class="self">self </span>. cmp (other)) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Ord <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>cmp (&amp; <span class="self">self </span>, other : &amp; <span class="self">Self</span>) -&gt; std :: cmp :: Ordering { <span class="self">self </span>. raw_id . cmp (&amp; other . raw_id) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Hash <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>hash &lt; H : std :: hash :: Hasher &gt; (&amp; <span class="self">self </span>, state : &amp; <span class="kw-2">mut </span>H) { <span class="self">self </span>. raw_id . hash (state) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; ClusterId &lt; C &gt; { <span class="kw">pub fn </span>from_raw (id : u32) -&gt; <span class="self">Self </span>{ ClusterId { raw_id : id , _phantom : PhantomData , } } } <span class="kw">pub use crate </span>:: location :: Cluster ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C &gt; Cluster &lt; <span class="lifetime">'a </span>, C &gt; { <span class="kw">pub fn </span>self_id (&amp; <span class="self">self</span>) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, ClusterId &lt; C &gt; &gt; + Copy + <span class="lifetime">'a </span>{ ClusterSelfId { id : <span class="self">self </span>. id , _phantom : PhantomData , } } <span class="kw">pub fn </span>members (&amp; <span class="self">self</span>) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, &amp; <span class="lifetime">'a </span>Vec &lt; ClusterId &lt; C &gt; &gt; &gt; + Copy + <span class="lifetime">'a </span>{ ClusterIds { id : <span class="self">self </span>. id , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C &gt; Clone <span class="kw">for </span>Cluster &lt; <span class="lifetime">'a </span>, C &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ Cluster { id : <span class="self">self </span>. id , flow_state : <span class="self">self </span>. flow_state . clone () , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C &gt; Location &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Cluster &lt; <span class="lifetime">'a </span>, C &gt; { <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; LocationId { LocationId :: Cluster (<span class="self">self </span>. id) } <span class="kw">fn </span>flow_state (&amp; <span class="self">self</span>) -&gt; &amp; FlowState { &amp; <span class="self">self </span>. flow_state } } <span class="kw">pub use crate </span>:: location :: CanSend ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, P1 , P2 &gt; CanSend &lt; <span class="lifetime">'a </span>, Process &lt; <span class="lifetime">'a </span>, P2 &gt; &gt; <span class="kw">for </span>Process &lt; <span class="lifetime">'a </span>, P1 &gt; { <span class="kw">type </span>In &lt; T &gt; = T ; <span class="kw">type </span>Out &lt; T &gt; = T ; <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">false </span>} <span class="kw">fn </span>tagged_type () -&gt; <span class="prelude-ty">Option </span>&lt; syn :: Type &gt; { <span class="prelude-val">None </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, P1 , C2 &gt; CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; <span class="kw">for </span>Process &lt; <span class="lifetime">'a </span>, P1 &gt; { <span class="kw">type </span>In &lt; T &gt; = (ClusterId &lt; C2 &gt; , T) ; <span class="kw">type </span>Out &lt; T &gt; = T ; <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>tagged_type () -&gt; <span class="prelude-ty">Option </span>&lt; syn :: Type &gt; { <span class="prelude-val">None </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C1 , P2 &gt; CanSend &lt; <span class="lifetime">'a </span>, Process &lt; <span class="lifetime">'a </span>, P2 &gt; &gt; <span class="kw">for </span>Cluster &lt; <span class="lifetime">'a </span>, C1 &gt; { <span class="kw">type </span>In &lt; T &gt; = T ; <span class="kw">type </span>Out &lt; T &gt; = (ClusterId &lt; C1 &gt; , T) ; <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">false </span>} <span class="kw">fn </span>tagged_type () -&gt; <span class="prelude-ty">Option </span>&lt; syn :: Type &gt; { <span class="prelude-val">Some </span>(quote_type :: &lt; C1 &gt; ()) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C1 , C2 &gt; CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; <span class="kw">for </span>Cluster &lt; <span class="lifetime">'a </span>, C1 &gt; { <span class="kw">type </span>In &lt; T &gt; = (ClusterId &lt; C2 &gt; , T) ; <span class="kw">type </span>Out &lt; T &gt; = (ClusterId &lt; C1 &gt; , T) ; <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>tagged_type () -&gt; <span class="prelude-ty">Option </span>&lt; syn :: Type &gt; { <span class="prelude-val">Some </span>(quote_type :: &lt; C1 &gt; ()) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, P1 , E2 &gt; CanSend &lt; <span class="lifetime">'a </span>, ExternalProcess &lt; <span class="lifetime">'a </span>, E2 &gt; &gt; <span class="kw">for </span>Process &lt; <span class="lifetime">'a </span>, P1 &gt; { <span class="kw">type </span>In &lt; T &gt; = T ; <span class="kw">type </span>Out &lt; T &gt; = T ; <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">false </span>} <span class="kw">fn </span>tagged_type () -&gt; <span class="prelude-ty">Option </span>&lt; syn :: Type &gt; { <span class="prelude-val">None </span>} } } <span class="kw">pub use </span>location :: { Cluster , ClusterId , Location , Process } ; <span class="kw">pub mod </span>deploy { <span class="kw">pub use </span>std :: future :: Future ; <span class="kw">pub use </span>std :: io :: Error ; <span class="kw">pub use </span>std :: pin :: Pin ; <span class="kw">pub use </span>hydroflow :: bytes :: Bytes ; <span class="kw">pub use </span>hydroflow :: futures :: { Sink , Stream } ; <span class="kw">pub use </span>hydroflow_lang :: graph :: HydroflowGraph ; <span class="kw">pub use </span>serde :: de :: DeserializeOwned ; <span class="kw">pub use </span>serde :: Serialize ; <span class="kw">pub use </span>stageleft :: Quoted ; # [cfg (feature = <span class="string">"deploy_runtime"</span>)] <span class="kw">pub mod </span>macro_runtime { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: pin :: Pin ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>hydroflow :: util :: deploy :: DeployPorts ; <span class="kw">pub use </span>stageleft :: { Quoted , RuntimeData } ; <span class="kw">pub use super </span>:: HydroflowPlusMeta ; <span class="kw">pub use crate </span>:: deploy :: { ClusterSpec , Deploy , ExternalSpec , Node , ProcessSpec , RegisterPort } ; <span class="kw">pub use crate </span>:: lang :: graph :: HydroflowGraph ; <span class="kw">pub use crate </span>:: deploy :: macro_runtime :: DeployRuntime ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Deploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>DeployRuntime { <span class="kw">type </span>InstantiateEnv = () ; <span class="kw">type </span>CompileEnv = RuntimeData &lt; &amp; <span class="lifetime">'a </span>DeployPorts &lt; HydroflowPlusMeta &gt; &gt; ; <span class="kw">type </span>Process = DeployRuntimeNode ; <span class="kw">type </span>Cluster = DeployRuntimeCluster ; <span class="kw">type </span>ExternalProcess = DeployRuntimeNode ; <span class="kw">type </span>Port = String ; <span class="kw">type </span>ExternalRawPort = () ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>GraphId = usize ; <span class="kw">fn </span>has_trivial_node () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>trivial_process (_id : usize) -&gt; <span class="self">Self </span>:: Process { DeployRuntimeNode { next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , } } <span class="kw">fn </span>trivail_cluster (_id : usize) -&gt; <span class="self">Self </span>:: Cluster { DeployRuntimeCluster { next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , } } <span class="kw">fn </span>allocate_process_port (process : &amp; <span class="self">Self </span>:: Process) -&gt; <span class="self">Self </span>:: Port { process . next_port () } <span class="kw">fn </span>allocate_cluster_port (cluster : &amp; <span class="self">Self </span>:: Cluster) -&gt; <span class="self">Self </span>:: Port { cluster . next_port () } <span class="kw">fn </span>allocate_external_port (_external : &amp; <span class="self">Self </span>:: ExternalProcess) -&gt; <span class="self">Self </span>:: Port { panic ! () ; } <span class="kw">fn </span>o2o_sink_source (env : &amp; <span class="self">Self </span>:: CompileEnv , _p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">super </span>:: deploy_runtime :: deploy_o2o (* env , p1_port . as_str () , p2_port . as_str ()) } <span class="kw">fn </span>o2o_connect (_p1 : &amp; <span class="self">Self </span>:: Process , _p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , _p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { Box :: new (| | panic ! ()) } <span class="kw">fn </span>o2m_sink_source (env : &amp; <span class="self">Self </span>:: CompileEnv , _p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , _c2 : &amp; <span class="self">Self </span>:: Cluster , c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">super </span>:: deploy_runtime :: deploy_o2m (* env , p1_port . as_str () , c2_port . as_str ()) } <span class="kw">fn </span>o2m_connect (_p1 : &amp; <span class="self">Self </span>:: Process , _p1_port : &amp; <span class="self">Self </span>:: Port , _c2 : &amp; <span class="self">Self </span>:: Cluster , _c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { Box :: new (| | panic ! ()) } <span class="kw">fn </span>m2o_sink_source (env : &amp; <span class="self">Self </span>:: CompileEnv , _c1 : &amp; <span class="self">Self </span>:: Cluster , c1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">super </span>:: deploy_runtime :: deploy_m2o (* env , c1_port . as_str () , p2_port . as_str ()) } <span class="kw">fn </span>m2o_connect (_c1 : &amp; <span class="self">Self </span>:: Cluster , _c1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , _p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { Box :: new (| | panic ! ()) } <span class="kw">fn </span>m2m_sink_source (env : &amp; <span class="self">Self </span>:: CompileEnv , _c1 : &amp; <span class="self">Self </span>:: Cluster , c1_port : &amp; <span class="self">Self </span>:: Port , _c2 : &amp; <span class="self">Self </span>:: Cluster , c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">super </span>:: deploy_runtime :: deploy_m2m (* env , c1_port . as_str () , c2_port . as_str ()) } <span class="kw">fn </span>m2m_connect (_c1 : &amp; <span class="self">Self </span>:: Cluster , _c1_port : &amp; <span class="self">Self </span>:: Port , _c2 : &amp; <span class="self">Self </span>:: Cluster , _c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { Box :: new (| | panic ! ()) } <span class="kw">fn </span>e2o_source (_compile_env : &amp; <span class="self">Self </span>:: CompileEnv , _p1 : &amp; <span class="self">Self </span>:: ExternalProcess , _p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , _p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; syn :: Expr { panic ! () } <span class="kw">fn </span>e2o_connect (_p1 : &amp; <span class="self">Self </span>:: ExternalProcess , _p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , _p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { panic ! () } <span class="kw">fn </span>o2e_sink (_compile_env : &amp; <span class="self">Self </span>:: CompileEnv , _p1 : &amp; <span class="self">Self </span>:: Process , _p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: ExternalProcess , _p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; syn :: Expr { panic ! () } <span class="kw">fn </span>o2e_connect (_p1 : &amp; <span class="self">Self </span>:: Process , _p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: ExternalProcess , _p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { panic ! () } <span class="kw">fn </span>cluster_ids (env : &amp; <span class="self">Self </span>:: CompileEnv , of_cluster : usize ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, &amp; <span class="lifetime">'a </span>Vec &lt; u32 &gt; &gt; + Copy + <span class="lifetime">'a </span>{ <span class="kw">super </span>:: deploy_runtime :: cluster_members (* env , of_cluster) } <span class="kw">fn </span>cluster_self_id (env : &amp; <span class="self">Self </span>:: CompileEnv) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, u32 &gt; + Copy + <span class="lifetime">'a </span>{ <span class="kw">super </span>:: deploy_runtime :: cluster_self_id (* env) } } <span class="kw">pub use crate </span>:: deploy :: macro_runtime :: DeployRuntimeNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; RegisterPort &lt; <span class="lifetime">'a </span>, DeployRuntime &gt; <span class="kw">for </span>DeployRuntimeNode { <span class="kw">fn </span>register (&amp; <span class="self">self </span>, _key : usize , _port : &lt; DeployRuntime <span class="kw">as </span>Deploy &gt; :: Port) { panic ! () } <span class="kw">fn </span>raw_port (&amp; <span class="self">self </span>, _key : usize) -&gt; &lt; DeployRuntime <span class="kw">as </span>Deploy &gt; :: ExternalRawPort { panic ! () } # [expect (clippy :: manual_async_fn , reason = <span class="string">"buggy Clippy lint for lifetime bounds"</span>)] <span class="kw">fn </span>as_bytes_sink (&amp; <span class="self">self </span>, _key : usize ,) -&gt; <span class="kw">impl </span>std :: future :: Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn crate </span>:: futures :: Sink &lt; <span class="kw">crate </span>:: bytes :: Bytes , Error = std :: io :: Error &gt; &gt; &gt; , &gt; + <span class="lifetime">'a </span>{ <span class="kw">async </span>{ panic ! () } } # [expect (clippy :: manual_async_fn , reason = <span class="string">"buggy Clippy lint for lifetime bounds"</span>)] <span class="kw">fn </span>as_bincode_sink &lt; T : serde :: Serialize + <span class="lifetime">'static </span>&gt; (&amp; <span class="self">self </span>, _key : usize ,) -&gt; <span class="kw">impl </span>std :: future :: Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn crate </span>:: futures :: Sink &lt; T , Error = std :: io :: Error &gt; &gt; &gt; , &gt; + <span class="lifetime">'a </span>{ <span class="kw">async </span>{ panic ! () } } # [expect (clippy :: manual_async_fn , reason = <span class="string">"buggy Clippy lint for lifetime bounds"</span>)] <span class="kw">fn </span>as_bytes_source (&amp; <span class="self">self </span>, _key : usize ,) -&gt; <span class="kw">impl </span>std :: future :: Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn </span>hydroflow :: futures :: Stream &lt; Item = hydroflow :: bytes :: Bytes &gt; &gt; &gt; , &gt; + <span class="lifetime">'a </span>{ <span class="kw">async </span>{ panic ! () } } # [expect (clippy :: manual_async_fn , reason = <span class="string">"buggy Clippy lint for lifetime bounds"</span>)] <span class="kw">fn </span>as_bincode_source &lt; T : serde :: de :: DeserializeOwned + <span class="lifetime">'static </span>&gt; (&amp; <span class="self">self </span>, _key : usize ,) -&gt; <span class="kw">impl </span>std :: future :: Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn </span>hydroflow :: futures :: Stream &lt; Item = T &gt; &gt; &gt; &gt; + <span class="lifetime">'a </span>{ <span class="kw">async </span>{ panic ! () } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>DeployRuntimeNode { <span class="kw">type </span>Port = String ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>InstantiateEnv = () ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) -&gt; String { <span class="kw">let </span>next_send_port = * <span class="self">self </span>. next_port . borrow () ; * <span class="self">self </span>. next_port . borrow_mut () += <span class="number">1 </span>; format ! (<span class="string">"port_{}" </span>, next_send_port) } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, _env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , _meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , _graph : HydroflowGraph , _extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { panic ! (<span class="string">".deploy() cannot be called on a DeployRuntimeNode"</span>) ; } } <span class="kw">pub use crate </span>:: deploy :: macro_runtime :: DeployRuntimeCluster ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>DeployRuntimeCluster { <span class="kw">type </span>Port = String ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>InstantiateEnv = () ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) -&gt; String { <span class="kw">let </span>next_send_port = * <span class="self">self </span>. next_port . borrow () ; * <span class="self">self </span>. next_port . borrow_mut () += <span class="number">1 </span>; format ! (<span class="string">"port_{}" </span>, next_send_port) } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, _env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , _meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , _graph : HydroflowGraph , _extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { panic ! (<span class="string">".deploy() cannot be called on a DeployRuntimeCluster"</span>) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; ProcessSpec &lt; <span class="lifetime">'a </span>, DeployRuntime &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (<span class="self">self </span>, _id : usize , _name_hint : &amp; str) -&gt; DeployRuntimeNode { DeployRuntimeNode { next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'cli </span>&gt; ClusterSpec &lt; <span class="lifetime">'cli </span>, DeployRuntime &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (<span class="self">self </span>, _id : usize , _name_hint : &amp; str) -&gt; DeployRuntimeCluster { DeployRuntimeCluster { next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'cli </span>&gt; ExternalSpec &lt; <span class="lifetime">'cli </span>, DeployRuntime &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (<span class="self">self </span>, _id : usize , _name_hint : &amp; str) -&gt; DeployRuntimeNode { panic ! () } } } # [cfg (feature = <span class="string">"deploy"</span>)] <span class="kw">pub mod </span>trybuild { <span class="kw">pub use </span>std :: fs ; <span class="kw">pub use </span>std :: path :: PathBuf ; <span class="kw">pub use </span>stageleft :: internal :: quote ; <span class="kw">pub use </span>trybuild_internals_api :: cargo :: { <span class="self">self </span>, Metadata } ; <span class="kw">pub use </span>trybuild_internals_api :: env :: Update ; <span class="kw">pub use </span>trybuild_internals_api :: run :: { PathDependency , Project } ; <span class="kw">pub use </span>trybuild_internals_api :: { dependencies , features , path , Runner } ; <span class="kw">pub use crate </span>:: lang :: graph :: { partition_graph , HydroflowGraph } ; <span class="kw">pub static </span>IS_TEST : std :: sync :: atomic :: AtomicBool = std :: sync :: atomic :: AtomicBool :: new (<span class="bool-val">false</span>) ; <span class="kw">pub fn </span>init_test () { IS_TEST . store (<span class="bool-val">true </span>, std :: sync :: atomic :: Ordering :: Relaxed) ; } <span class="kw">pub fn </span>compile_graph_trybuild (graph : HydroflowGraph , extra_stmts : Vec &lt; syn :: Stmt &gt;) -&gt; syn :: File { <span class="kw">let </span>partitioned_graph = partition_graph (graph) . expect (<span class="string">"Failed to partition (cycle detected)."</span>) ; <span class="kw">let </span><span class="kw-2">mut </span>diagnostics = Vec :: new () ; <span class="kw">let </span>tokens = partitioned_graph . as_code (&amp; quote ! { hydroflow_plus } , <span class="bool-val">true </span>, quote ! () , &amp; <span class="kw-2">mut </span>diagnostics) ; <span class="kw">let </span>source_ast : syn :: File = syn :: parse_quote ! { #! [feature (box_patterns)] #! [allow (unused_crate_dependencies , missing_docs)] <span class="kw">use </span>hydroflow_plus ::<span class="kw-2">*</span>; # [allow (unused)] <span class="kw">fn </span>__hfplus_runtime &lt;<span class="lifetime">'a </span>&gt; (__hydroflow_plus_trybuild_cli : <span class="kw-2">&amp;</span><span class="lifetime">'a </span>hydroflow_plus :: util :: deploy :: DeployPorts &lt; hydroflow_plus :: deploy :: HydroflowPlusMeta &gt;) -&gt; hydroflow_plus :: Hydroflow &lt;<span class="lifetime">'a </span>&gt; { # (# extra_stmts) * # tokens } # [tokio :: main] <span class="kw">async fn </span>main () { <span class="kw">let </span>ports = hydroflow_plus :: util :: deploy :: init_no_ack_start () . <span class="kw">await </span>; <span class="kw">let </span>flow = __hfplus_runtime (&amp; ports) ; println ! (<span class="string">"ack start"</span>) ; hydroflow_plus :: util :: deploy :: launch_flow (flow) . <span class="kw">await </span>; } } ; source_ast } <span class="kw">pub fn </span>create_trybuild (source : &amp; str , bin : &amp; str , is_test : bool ,) -&gt; <span class="prelude-ty">Result </span>&lt; (PathBuf , PathBuf , <span class="prelude-ty">Option </span>&lt; Vec &lt; String &gt; &gt;) , trybuild_internals_api :: error :: Error &gt; { <span class="kw">let </span>Metadata { target_directory : target_dir , workspace_root : workspace , packages , } = cargo :: metadata () <span class="question-mark">? </span>; <span class="kw">let </span>source_dir = cargo :: manifest_dir () <span class="question-mark">? </span>; <span class="kw">let </span><span class="kw-2">mut </span>source_manifest = dependencies :: get_manifest (&amp; source_dir) <span class="question-mark">? </span>; <span class="kw">if </span>! is_test { source_manifest . dev_dependencies . clear () ; } <span class="kw">let </span><span class="kw-2">mut </span>features = features :: find () ; <span class="kw">let </span>path_dependencies = source_manifest . dependencies . iter () . filter_map (| (name , dep) | { <span class="kw">let </span>path = dep . path . as_ref () <span class="question-mark">? </span>; <span class="kw">if </span>packages . iter () . any (| p | &amp; p . name == name) { <span class="prelude-val">None </span>} <span class="kw">else </span>{ <span class="prelude-val">Some </span>(PathDependency { name : name . clone () , normalized_path : path . canonicalize () . ok () <span class="question-mark">? </span>, }) } }) . collect () ; <span class="kw">let </span>crate_name = source_manifest . package . name . clone () ; <span class="kw">let </span>project_dir = path ! (target_dir / <span class="string">"hfplus_trybuild" </span>/ crate_name /) ; fs :: create_dir_all (&amp; project_dir) <span class="question-mark">? </span>; <span class="kw">let </span>project_name = format ! (<span class="string">"{}-hfplus-trybuild" </span>, crate_name) ; <span class="kw">let </span><span class="kw-2">mut </span>manifest = Runner :: make_manifest (&amp; workspace , &amp; project_name , &amp; source_dir , &amp; packages , &amp; [] , source_manifest ,) <span class="question-mark">? </span>; manifest . features . remove (<span class="string">"stageleft_devel"</span>) ; <span class="kw">if let </span><span class="prelude-val">Some </span>(enabled_features) = &amp; <span class="kw-2">mut </span>features { enabled_features . retain (| feature | manifest . features . contains_key (feature) || feature == <span class="string">"default"</span>) ; manifest . features . get_mut (<span class="string">"default"</span>) . iter_mut () . for_each (| v | { v . retain (| f | f != <span class="string">"stageleft_devel"</span>) ; }) ; } <span class="kw">let </span>project = Project { dir : project_dir , source_dir , target_dir , name : project_name , update : Update :: env () <span class="question-mark">? </span>, has_pass : <span class="bool-val">false </span>, has_compile_fail : <span class="bool-val">false </span>, features , workspace , path_dependencies , manifest , keep_going : <span class="bool-val">false </span>, } ; <span class="kw">let </span>manifest_toml = toml :: to_string (&amp; project . manifest) <span class="question-mark">? </span>; fs :: write (path ! (project . dir / <span class="string">"Cargo.toml"</span>) , manifest_toml) <span class="question-mark">? </span>; fs :: create_dir_all (path ! (project . dir / <span class="string">"src" </span>/ <span class="string">"bin"</span>)) <span class="question-mark">? </span>; <span class="kw">let </span>out_path = path ! (project . dir / <span class="string">"src" </span>/ <span class="string">"bin" </span>/ format ! (<span class="string">"{bin}.rs"</span>)) ; <span class="kw">if </span>! out_path . exists () || fs :: read_to_string (&amp; out_path) <span class="question-mark">? </span>!= source { fs :: write (path ! (project . dir / <span class="string">"src" </span>/ <span class="string">"bin" </span>/ format ! (<span class="string">"{bin}.rs"</span>)) , source ,) <span class="question-mark">? </span>; } <span class="kw">let </span>workspace_cargo_lock = path ! (project . workspace / <span class="string">"Cargo.lock"</span>) ; <span class="kw">if </span>workspace_cargo_lock . exists () { <span class="kw">let _ </span>= fs :: copy (workspace_cargo_lock , path ! (project . dir / <span class="string">"Cargo.lock"</span>)) ; } <span class="kw">else </span>{ <span class="kw">let _ </span>= cargo :: cargo (&amp; project) . arg (<span class="string">"generate-lockfile"</span>) . status () ; } <span class="kw">let </span>workspace_dot_cargo_config_toml = path ! (project . workspace / <span class="string">".cargo" </span>/ <span class="string">"config.toml"</span>) ; <span class="kw">if </span>workspace_dot_cargo_config_toml . exists () { <span class="kw">let </span>dot_cargo_folder = path ! (project . dir / <span class="string">".cargo"</span>) ; fs :: create_dir_all (&amp; dot_cargo_folder) <span class="question-mark">? </span>; <span class="kw">let _ </span>= fs :: copy (workspace_dot_cargo_config_toml , path ! (dot_cargo_folder / <span class="string">"config.toml"</span>) ,) ; } <span class="prelude-val">Ok </span>((project . dir . as_ref () . into () , path ! (project . target_dir / <span class="string">"hfplus_trybuild"</span>) , project . features ,)) } } <span class="kw">pub use </span>macro_runtime :: * ; # [cfg (feature = <span class="string">"deploy"</span>)] <span class="kw">pub use </span>trybuild :: init_test ; # [cfg (feature = <span class="string">"deploy_runtime"</span>)] <span class="kw">pub mod </span>deploy_runtime { <span class="kw">pub use </span>std :: collections :: HashMap ; <span class="kw">pub use </span>hydroflow :: util :: deploy :: { ConnectedDemux , ConnectedDirect , ConnectedSink , ConnectedSource , ConnectedTagged , DeployPorts , } ; <span class="kw">pub use </span>serde :: { Deserialize , Serialize } ; <span class="kw">pub use </span>stageleft :: { q , Quoted , RuntimeData } ; <span class="kw">pub use crate </span>:: deploy :: deploy_runtime :: HydroflowPlusMeta ; <span class="kw">pub fn </span>cluster_members (cli : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; , of_cluster : usize ,) -&gt; <span class="kw">impl </span>Quoted &lt; &amp; Vec &lt; u32 &gt; &gt; + Copy { q ! (cli . meta . clusters . get (&amp; of_cluster) . unwrap ()) } <span class="kw">pub fn </span>cluster_self_id (cli : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; u32 &gt; + Copy { q ! (cli . meta . cluster_id . expect (<span class="string">"Tried to read Cluster ID on a non-cluster node"</span>)) } <span class="kw">pub fn </span>deploy_o2o (env : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; , p1_port : &amp; str , p2_port : &amp; str ,) -&gt; (syn :: Expr , syn :: Expr) { ({ q ! ({ env . port (p1_port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_sink () }) . splice_untyped () } , { q ! ({ env . port (p2_port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_source () }) . splice_untyped () } ,) } <span class="kw">pub fn </span>deploy_o2m (env : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; , p1_port : &amp; str , c2_port : &amp; str ,) -&gt; (syn :: Expr , syn :: Expr) { ({ q ! ({ env . port (p1_port) . connect_local_blocking ::&lt; ConnectedDemux &lt; ConnectedDirect &gt;&gt; () . into_sink () }) . splice_untyped () } , { q ! ({ env . port (c2_port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_source () }) . splice_untyped () } ,) } <span class="kw">pub fn </span>deploy_m2o (env : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; , c1_port : &amp; str , p2_port : &amp; str ,) -&gt; (syn :: Expr , syn :: Expr) { ({ q ! ({ env . port (c1_port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_sink () }) . splice_untyped () } , { q ! ({ env . port (p2_port) . connect_local_blocking ::&lt; ConnectedTagged &lt; ConnectedDirect &gt;&gt; () . into_source () }) . splice_untyped () } ,) } <span class="kw">pub fn </span>deploy_m2m (env : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; , c1_port : &amp; str , c2_port : &amp; str ,) -&gt; (syn :: Expr , syn :: Expr) { ({ q ! ({ env . port (c1_port) . connect_local_blocking ::&lt; ConnectedDemux &lt; ConnectedDirect &gt;&gt; () . into_sink () }) . splice_untyped () } , { q ! ({ env . port (c2_port) . connect_local_blocking ::&lt; ConnectedTagged &lt; ConnectedDirect &gt;&gt; () . into_source () }) . splice_untyped () } ,) } <span class="kw">pub fn </span>deploy_e2o (env : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; , _e1_port : &amp; str , p2_port : &amp; str ,) -&gt; syn :: Expr { q ! ({ env . port (p2_port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_source () }) . splice_untyped () } <span class="kw">pub fn </span>deploy_o2e (env : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; , p1_port : &amp; str , _e2_port : &amp; str ,) -&gt; syn :: Expr { q ! ({ env . port (p1_port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_sink () }) . splice_untyped () } } # [cfg (feature = <span class="string">"deploy_runtime"</span>)] <span class="kw">pub use </span>deploy_runtime :: HydroflowPlusMeta ; # [cfg (feature = <span class="string">"deploy"</span>)] <span class="kw">pub mod </span>deploy_graph { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: collections :: HashMap ; <span class="kw">pub use </span>std :: future :: Future ; <span class="kw">pub use </span>std :: io :: Error ; <span class="kw">pub use </span>std :: pin :: Pin ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>std :: sync :: Arc ; <span class="kw">pub use </span>hydro_deploy :: custom_service :: CustomClientPort ; <span class="kw">pub use </span>hydro_deploy :: hydroflow_crate :: ports :: { DemuxSink , HydroflowSink , HydroflowSource , TaggedSource , } ; <span class="kw">pub use </span>hydro_deploy :: hydroflow_crate :: tracing_options :: TracingOptions ; <span class="kw">pub use </span>hydro_deploy :: hydroflow_crate :: HydroflowCrateService ; <span class="kw">pub use </span>hydro_deploy :: { CustomService , Deployment , Host , HydroflowCrate } ; <span class="kw">pub use </span>hydroflow :: futures :: StreamExt ; <span class="kw">pub use </span>hydroflow :: util :: deploy :: { ConnectedSink , ConnectedSource } ; <span class="kw">pub use </span>nameof :: name_of ; <span class="kw">pub use </span>serde :: de :: DeserializeOwned ; <span class="kw">pub use </span>serde :: Serialize ; <span class="kw">pub use </span>sha2 :: { Digest , Sha256 } ; <span class="kw">pub use </span>stageleft :: { Quoted , RuntimeData } ; <span class="kw">pub use </span>syn :: visit_mut :: VisitMut ; <span class="kw">pub use </span>tokio :: sync :: RwLock ; <span class="kw">pub use </span>trybuild_internals_api :: path ; <span class="kw">pub use super </span>:: deploy_runtime :: * ; <span class="kw">pub use super </span>:: trybuild :: { compile_graph_trybuild , create_trybuild } ; <span class="kw">pub use super </span>:: { ClusterSpec , Deploy , ExternalSpec , Node , ProcessSpec , RegisterPort } ; <span class="kw">pub use crate </span>:: futures :: SinkExt ; <span class="kw">pub use crate </span>:: lang :: graph :: HydroflowGraph ; <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: HydroDeploy ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Deploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>HydroDeploy { <span class="kw">type </span>InstantiateEnv = Deployment ; <span class="kw">type </span>CompileEnv = () ; <span class="kw">type </span>Process = DeployNode ; <span class="kw">type </span>Cluster = DeployCluster ; <span class="kw">type </span>ExternalProcess = DeployExternal ; <span class="kw">type </span>Meta = HashMap &lt; usize , Vec &lt; u32 &gt; &gt; ; <span class="kw">type </span>GraphId = () ; <span class="kw">type </span>Port = String ; <span class="kw">type </span>ExternalRawPort = CustomClientPort ; <span class="kw">fn </span>allocate_process_port (process : &amp; <span class="self">Self </span>:: Process) -&gt; <span class="self">Self </span>:: Port { process . next_port () } <span class="kw">fn </span>allocate_cluster_port (cluster : &amp; <span class="self">Self </span>:: Cluster) -&gt; <span class="self">Self </span>:: Port { cluster . next_port () } <span class="kw">fn </span>allocate_external_port (external : &amp; <span class="self">Self </span>:: ExternalProcess) -&gt; <span class="self">Self </span>:: Port { external . next_port () } <span class="kw">fn </span>o2o_sink_source (_env : &amp; () , _p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">let </span>p1_port = p1_port . as_str () ; <span class="kw">let </span>p2_port = p2_port . as_str () ; deploy_o2o (RuntimeData :: new (<span class="string">"__hydroflow_plus_trybuild_cli"</span>) , p1_port , p2_port ,) } <span class="kw">fn </span>o2o_connect (p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { <span class="kw">let </span>p1 = p1 . clone () ; <span class="kw">let </span>p1_port = p1_port . clone () ; <span class="kw">let </span>p2 = p2 . clone () ; <span class="kw">let </span>p2_port = p2_port . clone () ; Box :: new (<span class="kw">move </span>| | { <span class="kw">let </span>self_underlying_borrow = p1 . underlying . borrow () ; <span class="kw">let </span>self_underlying = self_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>source_port = self_underlying . try_read () . unwrap () . get_port (p1_port . clone () , self_underlying) ; <span class="kw">let </span>other_underlying_borrow = p2 . underlying . borrow () ; <span class="kw">let </span>other_underlying = other_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>recipient_port = other_underlying . try_read () . unwrap () . get_port (p2_port . clone () , other_underlying) ; source_port . send_to (&amp; recipient_port) }) } <span class="kw">fn </span>o2m_sink_source (_env : &amp; () , _p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , _c2 : &amp; <span class="self">Self </span>:: Cluster , c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">let </span>p1_port = p1_port . as_str () ; <span class="kw">let </span>c2_port = c2_port . as_str () ; deploy_o2m (RuntimeData :: new (<span class="string">"__hydroflow_plus_trybuild_cli"</span>) , p1_port , c2_port ,) } <span class="kw">fn </span>o2m_connect (p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , c2 : &amp; <span class="self">Self </span>:: Cluster , c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { <span class="kw">let </span>p1 = p1 . clone () ; <span class="kw">let </span>p1_port = p1_port . clone () ; <span class="kw">let </span>c2 = c2 . clone () ; <span class="kw">let </span>c2_port = c2_port . clone () ; Box :: new (<span class="kw">move </span>| | { <span class="kw">let </span>self_underlying_borrow = p1 . underlying . borrow () ; <span class="kw">let </span>self_underlying = self_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>source_port = self_underlying . try_read () . unwrap () . get_port (p1_port . clone () , self_underlying) ; <span class="kw">let </span>recipient_port = DemuxSink { demux : c2 . members . borrow () . iter () . enumerate () . map (| (id , c) | { <span class="kw">let </span>n = c . underlying . try_read () . unwrap () ; (id <span class="kw">as </span>u32 , Arc :: new (n . get_port (c2_port . clone () , &amp; c . underlying)) <span class="kw">as </span>Arc &lt; <span class="kw">dyn </span>HydroflowSink + <span class="lifetime">'static </span>&gt; ,) }) . collect () , } ; source_port . send_to (&amp; recipient_port) }) } <span class="kw">fn </span>m2o_sink_source (_env : &amp; () , _c1 : &amp; <span class="self">Self </span>:: Cluster , c1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">let </span>c1_port = c1_port . as_str () ; <span class="kw">let </span>p2_port = p2_port . as_str () ; deploy_m2o (RuntimeData :: new (<span class="string">"__hydroflow_plus_trybuild_cli"</span>) , c1_port , p2_port ,) } <span class="kw">fn </span>m2o_connect (c1 : &amp; <span class="self">Self </span>:: Cluster , c1_port : &amp; <span class="self">Self </span>:: Port , p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { <span class="kw">let </span>c1 = c1 . clone () ; <span class="kw">let </span>c1_port = c1_port . clone () ; <span class="kw">let </span>p2 = p2 . clone () ; <span class="kw">let </span>p2_port = p2_port . clone () ; Box :: new (<span class="kw">move </span>| | { <span class="kw">let </span>other_underlying_borrow = p2 . underlying . borrow () ; <span class="kw">let </span>other_underlying = other_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>recipient_port = other_underlying . try_read () . unwrap () . get_port (p2_port . clone () , other_underlying) . merge () ; <span class="kw">for </span>(i , node) <span class="kw">in </span>c1 . members . borrow () . iter () . enumerate () { <span class="kw">let </span>source_port = node . underlying . try_read () . unwrap () . get_port (c1_port . clone () , &amp; node . underlying) ; TaggedSource { source : Arc :: new (source_port) , tag : i <span class="kw">as </span>u32 , } . send_to (&amp; recipient_port) ; } }) } <span class="kw">fn </span>m2m_sink_source (_env : &amp; () , _c1 : &amp; <span class="self">Self </span>:: Cluster , c1_port : &amp; <span class="self">Self </span>:: Port , _c2 : &amp; <span class="self">Self </span>:: Cluster , c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">let </span>c1_port = c1_port . as_str () ; <span class="kw">let </span>c2_port = c2_port . as_str () ; deploy_m2m (RuntimeData :: new (<span class="string">"__hydroflow_plus_trybuild_cli"</span>) , c1_port , c2_port ,) } <span class="kw">fn </span>m2m_connect (c1 : &amp; <span class="self">Self </span>:: Cluster , c1_port : &amp; <span class="self">Self </span>:: Port , c2 : &amp; <span class="self">Self </span>:: Cluster , c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { <span class="kw">let </span>c1 = c1 . clone () ; <span class="kw">let </span>c1_port = c1_port . clone () ; <span class="kw">let </span>c2 = c2 . clone () ; <span class="kw">let </span>c2_port = c2_port . clone () ; Box :: new (<span class="kw">move </span>| | { <span class="kw">for </span>(i , sender) <span class="kw">in </span>c1 . members . borrow () . iter () . enumerate () { <span class="kw">let </span>source_port = sender . underlying . try_read () . unwrap () . get_port (c1_port . clone () , &amp; sender . underlying) ; <span class="kw">let </span>recipient_port = DemuxSink { demux : c2 . members . borrow () . iter () . enumerate () . map (| (id , c) | { <span class="kw">let </span>n = c . underlying . try_read () . unwrap () ; (id <span class="kw">as </span>u32 , Arc :: new (n . get_port (c2_port . clone () , &amp; c . underlying) . merge ()) <span class="kw">as </span>Arc &lt; <span class="kw">dyn </span>HydroflowSink + <span class="lifetime">'static </span>&gt; ,) }) . collect () , } ; TaggedSource { source : Arc :: new (source_port) , tag : i <span class="kw">as </span>u32 , } . send_to (&amp; recipient_port) ; } }) } <span class="kw">fn </span>e2o_source (_compile_env : &amp; <span class="self">Self </span>:: CompileEnv , _p1 : &amp; <span class="self">Self </span>:: ExternalProcess , p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; syn :: Expr { <span class="kw">let </span>p1_port = p1_port . as_str () ; <span class="kw">let </span>p2_port = p2_port . as_str () ; deploy_e2o (RuntimeData :: new (<span class="string">"__hydroflow_plus_trybuild_cli"</span>) , p1_port , p2_port ,) } <span class="kw">fn </span>e2o_connect (p1 : &amp; <span class="self">Self </span>:: ExternalProcess , p1_port : &amp; <span class="self">Self </span>:: Port , p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { <span class="kw">let </span>p1 = p1 . clone () ; <span class="kw">let </span>p1_port = p1_port . clone () ; <span class="kw">let </span>p2 = p2 . clone () ; <span class="kw">let </span>p2_port = p2_port . clone () ; Box :: new (<span class="kw">move </span>| | { <span class="kw">let </span>self_underlying_borrow = p1 . underlying . borrow () ; <span class="kw">let </span>self_underlying = self_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>source_port = self_underlying . try_read () . unwrap () . declare_client (self_underlying) ; <span class="kw">let </span>other_underlying_borrow = p2 . underlying . borrow () ; <span class="kw">let </span>other_underlying = other_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>recipient_port = other_underlying . try_read () . unwrap () . get_port (p2_port . clone () , other_underlying) ; source_port . send_to (&amp; recipient_port) ; p1 . client_ports . borrow_mut () . insert (p1_port . clone () , source_port) ; }) } <span class="kw">fn </span>o2e_sink (_compile_env : &amp; <span class="self">Self </span>:: CompileEnv , _p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: ExternalProcess , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; syn :: Expr { <span class="kw">let </span>p1_port = p1_port . as_str () ; <span class="kw">let </span>p2_port = p2_port . as_str () ; deploy_o2e (RuntimeData :: new (<span class="string">"__hydroflow_plus_trybuild_cli"</span>) , p1_port , p2_port ,) } <span class="kw">fn </span>o2e_connect (p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , p2 : &amp; <span class="self">Self </span>:: ExternalProcess , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { <span class="kw">let </span>p1 = p1 . clone () ; <span class="kw">let </span>p1_port = p1_port . clone () ; <span class="kw">let </span>p2 = p2 . clone () ; <span class="kw">let </span>p2_port = p2_port . clone () ; Box :: new (<span class="kw">move </span>| | { <span class="kw">let </span>self_underlying_borrow = p1 . underlying . borrow () ; <span class="kw">let </span>self_underlying = self_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>source_port = self_underlying . try_read () . unwrap () . get_port (p1_port . clone () , self_underlying) ; <span class="kw">let </span>other_underlying_borrow = p2 . underlying . borrow () ; <span class="kw">let </span>other_underlying = other_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>recipient_port = other_underlying . try_read () . unwrap () . declare_client (other_underlying) ; source_port . send_to (&amp; recipient_port) ; p2 . client_ports . borrow_mut () . insert (p2_port . clone () , recipient_port) ; }) } <span class="kw">fn </span>cluster_ids (_env : &amp; <span class="self">Self </span>:: CompileEnv , of_cluster : usize ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, &amp; <span class="lifetime">'a </span>Vec &lt; u32 &gt; &gt; + Copy + <span class="lifetime">'a </span>{ cluster_members (RuntimeData :: new (<span class="string">"__hydroflow_plus_trybuild_cli"</span>) , of_cluster ,) } <span class="kw">fn </span>cluster_self_id (_env : &amp; <span class="self">Self </span>:: CompileEnv) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, u32 &gt; + Copy + <span class="lifetime">'a </span>{ cluster_self_id (RuntimeData :: new (<span class="string">"__hydroflow_plus_trybuild_cli"</span>)) } } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: DeployCrateWrapper ; <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: TrybuildHost ; # [cfg (stageleft_macro)] <span class="kw">impl </span>TrybuildHost { <span class="kw">pub fn </span>new (host : Arc &lt; <span class="kw">dyn </span>Host &gt;) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>{ host , display_name : <span class="prelude-val">None </span>, rustflags : <span class="prelude-val">None </span>, tracing : <span class="prelude-val">None </span>, name_hint : <span class="prelude-val">None </span>, cluster_idx : <span class="prelude-val">None </span>, } } <span class="kw">pub fn </span>display_name (<span class="self">self </span>, display_name : <span class="kw">impl </span>Into &lt; String &gt;) -&gt; <span class="self">Self </span>{ <span class="kw">if </span><span class="self">self </span>. display_name . is_some () { panic ! (<span class="string">"{} already set" </span>, name_of ! (display_name <span class="kw">in </span><span class="self">Self</span>)) ; } <span class="self">Self </span>{ display_name : <span class="prelude-val">Some </span>(display_name . into ()) , .. <span class="self">self </span>} } <span class="kw">pub fn </span>rustflags (<span class="self">self </span>, rustflags : <span class="kw">impl </span>Into &lt; String &gt;) -&gt; <span class="self">Self </span>{ <span class="kw">if </span><span class="self">self </span>. rustflags . is_some () { panic ! (<span class="string">"{} already set" </span>, name_of ! (rustflags <span class="kw">in </span><span class="self">Self</span>)) ; } <span class="self">Self </span>{ rustflags : <span class="prelude-val">Some </span>(rustflags . into ()) , .. <span class="self">self </span>} } <span class="kw">pub fn </span>tracing (<span class="self">self </span>, tracing : TracingOptions) -&gt; <span class="self">Self </span>{ <span class="kw">if </span><span class="self">self </span>. tracing . is_some () { panic ! (<span class="string">"{} already set" </span>, name_of ! (tracing <span class="kw">in </span><span class="self">Self</span>)) ; } <span class="self">Self </span>{ tracing : <span class="prelude-val">Some </span>(tracing) , .. <span class="self">self </span>} } } # [cfg (stageleft_macro)] <span class="kw">impl </span>From &lt; Arc &lt; <span class="kw">dyn </span>Host &gt; &gt; <span class="kw">for </span>TrybuildHost { <span class="kw">fn </span>from (h : Arc &lt; <span class="kw">dyn </span>Host &gt;) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>{ host : h , display_name : <span class="prelude-val">None </span>, rustflags : <span class="prelude-val">None </span>, tracing : <span class="prelude-val">None </span>, name_hint : <span class="prelude-val">None </span>, cluster_idx : <span class="prelude-val">None </span>, } } } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: DeployExternal ; # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployExternal { <span class="kw">pub fn </span>take_port (&amp; <span class="self">self </span>, key : usize) -&gt; CustomClientPort { <span class="self">self </span>. client_ports . borrow_mut () . remove (<span class="self">self </span>. allocated_ports . borrow () . get (&amp; key) . unwrap ()) . unwrap () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; RegisterPort &lt; <span class="lifetime">'a </span>, HydroDeploy &gt; <span class="kw">for </span>DeployExternal { <span class="kw">fn </span>register (&amp; <span class="self">self </span>, key : usize , port : &lt; HydroDeploy <span class="kw">as </span>Deploy &gt; :: Port) { <span class="self">self </span>. allocated_ports . borrow_mut () . insert (key , port) ; } <span class="kw">fn </span>raw_port (&amp; <span class="self">self </span>, key : usize) -&gt; &lt; HydroDeploy <span class="kw">as </span>Deploy &gt; :: ExternalRawPort { <span class="self">self </span>. client_ports . borrow_mut () . remove (<span class="self">self </span>. allocated_ports . borrow () . get (&amp; key) . unwrap ()) . unwrap () } <span class="kw">fn </span>as_bytes_sink (&amp; <span class="self">self </span>, key : usize ,) -&gt; <span class="kw">impl </span>Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn crate </span>:: futures :: Sink &lt; <span class="kw">crate </span>:: bytes :: Bytes , Error = Error &gt; &gt; &gt; &gt; + <span class="lifetime">'a </span>{ <span class="kw">let </span>port = <span class="self">self </span>. raw_port (key) ; <span class="kw">async move </span>{ <span class="kw">let </span>sink = port . connect () . <span class="kw">await </span>. into_sink () ; sink <span class="kw">as </span>Pin &lt; Box &lt; <span class="kw">dyn crate </span>:: futures :: Sink &lt; <span class="kw">crate </span>:: bytes :: Bytes , Error = Error &gt; &gt; &gt; } } <span class="kw">fn </span>as_bincode_sink &lt; T : Serialize + <span class="lifetime">'static </span>&gt; (&amp; <span class="self">self </span>, key : usize ,) -&gt; <span class="kw">impl </span>Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn crate </span>:: futures :: Sink &lt; T , Error = Error &gt; &gt; &gt; &gt; + <span class="lifetime">'a </span>{ <span class="kw">let </span>port = <span class="self">self </span>. raw_port (key) ; <span class="kw">async move </span>{ <span class="kw">let </span>sink = port . connect () . <span class="kw">await </span>. into_sink () ; Box :: pin (sink . with (| item | <span class="kw">async move </span>{ <span class="prelude-val">Ok </span>(bincode :: serialize (&amp; item) . unwrap () . into ()) })) <span class="kw">as </span>Pin &lt; Box &lt; <span class="kw">dyn crate </span>:: futures :: Sink &lt; T , Error = Error &gt; &gt; &gt; } } <span class="kw">fn </span>as_bytes_source (&amp; <span class="self">self </span>, key : usize ,) -&gt; <span class="kw">impl </span>Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn crate </span>:: futures :: Stream &lt; Item = <span class="kw">crate </span>:: bytes :: Bytes &gt; &gt; &gt; &gt; + <span class="lifetime">'a </span>{ <span class="kw">let </span>port = <span class="self">self </span>. raw_port (key) ; <span class="kw">async move </span>{ <span class="kw">let </span>source = port . connect () . <span class="kw">await </span>. into_source () ; Box :: pin (source . map (| r | r . unwrap () . freeze ())) <span class="kw">as </span>Pin &lt; Box &lt; <span class="kw">dyn crate </span>:: futures :: Stream &lt; Item = <span class="kw">crate </span>:: bytes :: Bytes &gt; &gt; &gt; } } <span class="kw">fn </span>as_bincode_source &lt; T : DeserializeOwned + <span class="lifetime">'static </span>&gt; (&amp; <span class="self">self </span>, key : usize ,) -&gt; <span class="kw">impl </span>Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn crate </span>:: futures :: Stream &lt; Item = T &gt; &gt; &gt; &gt; + <span class="lifetime">'a </span>{ <span class="kw">let </span>port = <span class="self">self </span>. raw_port (key) ; <span class="kw">async move </span>{ <span class="kw">let </span>source = port . connect () . <span class="kw">await </span>. into_source () ; Box :: pin (source . map (| item | bincode :: deserialize (&amp; item . unwrap ()) . unwrap ())) <span class="kw">as </span>Pin &lt; Box &lt; <span class="kw">dyn crate </span>:: futures :: Stream &lt; Item = T &gt; &gt; &gt; } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>DeployExternal { <span class="kw">type </span>Port = String ; <span class="kw">type </span>Meta = HashMap &lt; usize , Vec &lt; u32 &gt; &gt; ; <span class="kw">type </span>InstantiateEnv = Deployment ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>:: Port { <span class="kw">let </span>next_port = * <span class="self">self </span>. next_port . borrow () ; * <span class="self">self </span>. next_port . borrow_mut () += <span class="number">1 </span>; format ! (<span class="string">"port_{}" </span>, next_port) } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , _meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , _graph : HydroflowGraph , _extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { <span class="kw">let </span>service = env . CustomService (<span class="self">self </span>. host . clone () , vec ! []) ; * <span class="self">self </span>. underlying . borrow_mut () = <span class="prelude-val">Some </span>(service) ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; ExternalSpec &lt; <span class="lifetime">'a </span>, HydroDeploy &gt; <span class="kw">for </span>Arc &lt; <span class="kw">dyn </span>Host &gt; { <span class="kw">fn </span>build (<span class="self">self </span>, _id : usize , _name_hint : &amp; str) -&gt; DeployExternal { DeployExternal { next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , host : <span class="self">self </span>, underlying : Rc :: new (RefCell :: new (<span class="prelude-val">None</span>)) , allocated_ports : Rc :: new (RefCell :: new (HashMap :: new ())) , client_ports : Rc :: new (RefCell :: new (HashMap :: new ())) , } } } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: CrateOrTrybuild ; <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: DeployNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployCrateWrapper <span class="kw">for </span>DeployNode { <span class="kw">fn </span>underlying (&amp; <span class="self">self</span>) -&gt; Arc &lt; RwLock &lt; HydroflowCrateService &gt; &gt; { <span class="self">self </span>. underlying . borrow () . as_ref () . unwrap () . clone () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>DeployNode { <span class="kw">type </span>Port = String ; <span class="kw">type </span>Meta = HashMap &lt; usize , Vec &lt; u32 &gt; &gt; ; <span class="kw">type </span>InstantiateEnv = Deployment ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) -&gt; String { <span class="kw">let </span>next_port = * <span class="self">self </span>. next_port . borrow () ; * <span class="self">self </span>. next_port . borrow_mut () += <span class="number">1 </span>; format ! (<span class="string">"port_{}" </span>, next_port) } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, meta : &amp; <span class="self">Self </span>:: Meta) { <span class="kw">let </span>underlying_node = <span class="self">self </span>. underlying . borrow () ; <span class="kw">let </span><span class="kw-2">mut </span>n = underlying_node . as_ref () . unwrap () . try_write () . unwrap () ; n . update_meta (HydroflowPlusMeta { clusters : meta . clone () , cluster_id : <span class="prelude-val">None </span>, subgraph_id : <span class="self">self </span>. id , }) ; } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , _meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , graph : HydroflowGraph , extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { <span class="kw">let </span>service = <span class="kw">match </span><span class="self">self </span>. service_spec . borrow_mut () . take () . unwrap () { CrateOrTrybuild :: Crate (c) =&gt; c , CrateOrTrybuild :: Trybuild (trybuild) =&gt; { <span class="kw">let </span>(bin_name , (dir , target_dir , features)) = create_graph_trybuild (graph , extra_stmts , &amp; trybuild . name_hint) ; create_trybuild_service (trybuild , &amp; dir , &amp; target_dir , &amp; features , &amp; bin_name) } } ; * <span class="self">self </span>. underlying . borrow_mut () = <span class="prelude-val">Some </span>(env . add_service (service)) ; } } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: DeployClusterNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployCrateWrapper <span class="kw">for </span>DeployClusterNode { <span class="kw">fn </span>underlying (&amp; <span class="self">self</span>) -&gt; Arc &lt; RwLock &lt; HydroflowCrateService &gt; &gt; { <span class="self">self </span>. underlying . clone () } } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: DeployCluster ; # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployCluster { <span class="kw">pub fn </span>members (&amp; <span class="self">self</span>) -&gt; Vec &lt; DeployClusterNode &gt; { <span class="self">self </span>. members . borrow () . clone () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>DeployCluster { <span class="kw">type </span>Port = String ; <span class="kw">type </span>Meta = HashMap &lt; usize , Vec &lt; u32 &gt; &gt; ; <span class="kw">type </span>InstantiateEnv = Deployment ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) -&gt; String { <span class="kw">let </span>next_port = * <span class="self">self </span>. next_port . borrow () ; * <span class="self">self </span>. next_port . borrow_mut () += <span class="number">1 </span>; format ! (<span class="string">"port_{}" </span>, next_port) } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , graph : HydroflowGraph , extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { <span class="kw">let </span>has_trybuild = <span class="self">self </span>. cluster_spec . borrow () . as_ref () . unwrap () . iter () . any (| spec | matches ! (spec , CrateOrTrybuild :: Trybuild { .. })) ; <span class="kw">let </span>maybe_trybuild = <span class="kw">if </span>has_trybuild { <span class="prelude-val">Some </span>(create_graph_trybuild (graph , extra_stmts , &amp; <span class="self">self </span>. name_hint)) } <span class="kw">else </span>{ <span class="prelude-val">None </span>} ; <span class="kw">let </span>cluster_nodes = <span class="self">self </span>. cluster_spec . borrow_mut () . take () . unwrap () . into_iter () . map (| spec | { <span class="kw">let </span>service = <span class="kw">match </span>spec { CrateOrTrybuild :: Crate (c) =&gt; c , CrateOrTrybuild :: Trybuild (trybuild) =&gt; { <span class="kw">let </span>(bin_name , (dir , target_dir , features)) = maybe_trybuild . as_ref () . unwrap () ; create_trybuild_service (trybuild , dir , target_dir , features , bin_name) } } ; env . add_service (service) }) . collect :: &lt; Vec &lt; <span class="kw">_ </span>&gt; &gt; () ; meta . insert (<span class="self">self </span>. id , (<span class="number">0 </span>.. (cluster_nodes . len () <span class="kw">as </span>u32)) . collect ()) ; * <span class="self">self </span>. members . borrow_mut () = cluster_nodes . into_iter () . map (| n | DeployClusterNode { underlying : n }) . collect () ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, meta : &amp; <span class="self">Self </span>:: Meta) { <span class="kw">for </span>(cluster_id , node) <span class="kw">in </span><span class="self">self </span>. members . borrow () . iter () . enumerate () { <span class="kw">let </span><span class="kw-2">mut </span>n = node . underlying . try_write () . unwrap () ; n . update_meta (HydroflowPlusMeta { clusters : meta . clone () , cluster_id : <span class="prelude-val">Some </span>(cluster_id <span class="kw">as </span>u32) , subgraph_id : <span class="self">self </span>. id , }) ; } } } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: DeployProcessSpec ; # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployProcessSpec { <span class="kw">pub fn </span>new (t : HydroflowCrate) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>(t) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; ProcessSpec &lt; <span class="lifetime">'a </span>, HydroDeploy &gt; <span class="kw">for </span>DeployProcessSpec { <span class="kw">fn </span>build (<span class="self">self </span>, id : usize , _name_hint : &amp; str) -&gt; DeployNode { DeployNode { id , next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , service_spec : Rc :: new (RefCell :: new (<span class="prelude-val">Some </span>(CrateOrTrybuild :: Crate (<span class="self">self </span>. <span class="number">0</span>)))) , underlying : Rc :: new (RefCell :: new (<span class="prelude-val">None</span>)) , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; ProcessSpec &lt; <span class="lifetime">'a </span>, HydroDeploy &gt; <span class="kw">for </span>TrybuildHost { <span class="kw">fn </span>build (<span class="kw-2">mut </span><span class="self">self </span>, id : usize , name_hint : &amp; str) -&gt; DeployNode { <span class="self">self </span>. name_hint = <span class="prelude-val">Some </span>(format ! (<span class="string">"{} (process {id})" </span>, name_hint)) ; DeployNode { id , next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , service_spec : Rc :: new (RefCell :: new (<span class="prelude-val">Some </span>(CrateOrTrybuild :: Trybuild (<span class="self">self</span>)))) , underlying : Rc :: new (RefCell :: new (<span class="prelude-val">None</span>)) , } } } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: DeployClusterSpec ; # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployClusterSpec { <span class="kw">pub fn </span>new (crates : Vec &lt; HydroflowCrate &gt;) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>(crates) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; ClusterSpec &lt; <span class="lifetime">'a </span>, HydroDeploy &gt; <span class="kw">for </span>DeployClusterSpec { <span class="kw">fn </span>build (<span class="self">self </span>, id : usize , _name_hint : &amp; str) -&gt; DeployCluster { DeployCluster { id , next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , cluster_spec : Rc :: new (RefCell :: new (<span class="prelude-val">Some </span>(<span class="self">self </span>. <span class="number">0 </span>. into_iter () . map (CrateOrTrybuild :: Crate) . collect () ,))) , members : Rc :: new (RefCell :: new (vec ! [])) , name_hint : <span class="prelude-val">None </span>, } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; ClusterSpec &lt; <span class="lifetime">'a </span>, HydroDeploy &gt; <span class="kw">for </span>Vec &lt; TrybuildHost &gt; { <span class="kw">fn </span>build (<span class="self">self </span>, id : usize , name_hint : &amp; str) -&gt; DeployCluster { <span class="kw">let </span>name_hint = format ! (<span class="string">"{} (cluster {id})" </span>, name_hint) ; DeployCluster { id , next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , cluster_spec : Rc :: new (RefCell :: new (<span class="prelude-val">Some </span>(<span class="self">self </span>. into_iter () . enumerate () . map (| (idx , <span class="kw-2">mut </span>b) | { b . name_hint = <span class="prelude-val">Some </span>(name_hint . clone ()) ; b . cluster_idx = <span class="prelude-val">Some </span>(idx) ; CrateOrTrybuild :: Trybuild (b) }) . collect () ,))) , members : Rc :: new (RefCell :: new (vec ! [])) , name_hint : <span class="prelude-val">Some </span>(name_hint) , } } } <span class="kw">pub fn </span>clean_name_hint (name_hint : &amp; str) -&gt; String { name_hint . replace (<span class="string">"::" </span>, <span class="string">"__"</span>) . replace (<span class="string">" " </span>, <span class="string">"_"</span>) . replace (<span class="string">"," </span>, <span class="string">"_"</span>) . replace (<span class="string">"&lt;" </span>, <span class="string">"_"</span>) . replace (<span class="string">"&gt;" </span>, <span class="string">""</span>) . replace (<span class="string">"(" </span>, <span class="string">""</span>) . replace (<span class="string">")" </span>, <span class="string">""</span>) } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: ReplaceCrateNameWithStaged ; # [cfg (stageleft_macro)] <span class="kw">impl </span>VisitMut <span class="kw">for </span>ReplaceCrateNameWithStaged { <span class="kw">fn </span>visit_type_path_mut (&amp; <span class="kw-2">mut </span><span class="self">self </span>, i : &amp; <span class="kw-2">mut </span>syn :: TypePath) { <span class="kw">if let </span><span class="prelude-val">Some </span>(first) = i . path . segments . first () { <span class="kw">if </span>first . ident == <span class="self">self </span>. crate_name { <span class="kw">let </span>tail = i . path . segments . iter () . skip (<span class="number">1</span>) . collect :: &lt; Vec &lt; <span class="kw">_ </span>&gt; &gt; () ; * i = syn :: parse_quote ! (<span class="kw">crate </span>:: __staged # (::# tail) <span class="kw-2">*</span>) ; } } syn :: visit_mut :: visit_type_path_mut (<span class="self">self </span>, i) ; } } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: ReplaceCrateWithOrig ; # [cfg (stageleft_macro)] <span class="kw">impl </span>VisitMut <span class="kw">for </span>ReplaceCrateWithOrig { <span class="kw">fn </span>visit_item_use_mut (&amp; <span class="kw-2">mut </span><span class="self">self </span>, i : &amp; <span class="kw-2">mut </span>syn :: ItemUse) { <span class="kw">if let </span>syn :: UseTree :: Path (p) = &amp; <span class="kw-2">mut </span>i . tree { <span class="kw">if </span>p . ident == <span class="string">"crate" </span>{ p . ident = syn :: Ident :: new (&amp; <span class="self">self </span>. crate_name , p . ident . span ()) ; i . leading_colon = <span class="prelude-val">Some </span>(Default :: default ()) ; } } syn :: visit_mut :: visit_item_use_mut (<span class="self">self </span>, i) ; } } <span class="kw">pub fn </span>create_graph_trybuild (graph : HydroflowGraph , extra_stmts : Vec &lt; syn :: Stmt &gt; , name_hint : &amp; <span class="prelude-ty">Option </span>&lt; String &gt; ,) -&gt; (String , (std :: path :: PathBuf , std :: path :: PathBuf , <span class="prelude-ty">Option </span>&lt; Vec &lt; String &gt; &gt;) ,) { <span class="kw">let </span>source_dir = trybuild_internals_api :: cargo :: manifest_dir () . unwrap () ; <span class="kw">let </span>source_manifest = trybuild_internals_api :: dependencies :: get_manifest (&amp; source_dir) . unwrap () ; <span class="kw">let </span>crate_name = &amp; source_manifest . package . name . to_string () . replace (<span class="string">"-" </span>, <span class="string">"_"</span>) ; <span class="kw">let </span>is_test = <span class="kw">super </span>:: trybuild :: IS_TEST . load (std :: sync :: atomic :: Ordering :: Relaxed) ; <span class="kw">let </span><span class="kw-2">mut </span>generated_code = compile_graph_trybuild (graph , extra_stmts) ; ReplaceCrateNameWithStaged { crate_name : crate_name . clone () , } . visit_file_mut (&amp; <span class="kw-2">mut </span>generated_code) ; <span class="kw">let </span><span class="kw-2">mut </span>inlined_staged = stageleft_tool :: gen_staged_trybuild (&amp; path ! (source_dir / <span class="string">"src" </span>/ <span class="string">"lib.rs"</span>) , crate_name . clone () , is_test ,) ; ReplaceCrateWithOrig { crate_name : crate_name . clone () , } . visit_file_mut (&amp; <span class="kw-2">mut </span>inlined_staged) ; <span class="kw">let </span>source = prettyplease :: unparse (&amp; syn :: parse_quote ! { # generated_code # [allow (unused , ambiguous_glob_reexports , clippy :: suspicious_else_formatting , unexpected_cfgs , reason = <span class="string">"generated code"</span>)] <span class="kw">pub mod </span>__staged { # inlined_staged } }) ; <span class="kw">let </span><span class="kw-2">mut </span>hasher = Sha256 :: new () ; hasher . update (&amp; source) ; <span class="kw">let </span>hash = format ! (<span class="string">"{:X}" </span>, hasher . finalize ()) . chars () . take (<span class="number">8</span>) . collect :: &lt; String &gt; () ; <span class="kw">let </span>bin_name = <span class="kw">if let </span><span class="prelude-val">Some </span>(name_hint) = &amp; name_hint { format ! (<span class="string">"{}_{}" </span>, clean_name_hint (name_hint) , &amp; hash) } <span class="kw">else </span>{ hash } ; <span class="kw">let </span>trybuild_created = create_trybuild (&amp; source , &amp; bin_name , is_test) . unwrap () ; (bin_name , trybuild_created) } <span class="kw">pub fn </span>create_trybuild_service (trybuild : TrybuildHost , dir : &amp; std :: path :: PathBuf , target_dir : &amp; std :: path :: PathBuf , features : &amp; <span class="prelude-ty">Option </span>&lt; Vec &lt; String &gt; &gt; , bin_name : &amp; str ,) -&gt; HydroflowCrate { <span class="kw">let </span><span class="kw-2">mut </span>ret = HydroflowCrate :: new (dir , trybuild . host) . target_dir (target_dir) . bin (bin_name) . no_default_features () ; <span class="kw">if let </span><span class="prelude-val">Some </span>(display_name) = trybuild . display_name { ret = ret . display_name (display_name) ; } <span class="kw">else if let </span><span class="prelude-val">Some </span>(name_hint) = trybuild . name_hint { <span class="kw">if let </span><span class="prelude-val">Some </span>(cluster_idx) = trybuild . cluster_idx { ret = ret . display_name (format ! (<span class="string">"{} / {}" </span>, name_hint , cluster_idx)) ; } <span class="kw">else </span>{ ret = ret . display_name (name_hint) ; } } <span class="kw">if let </span><span class="prelude-val">Some </span>(rustflags) = trybuild . rustflags { ret = ret . rustflags (rustflags) ; } <span class="kw">if let </span><span class="prelude-val">Some </span>(tracing) = trybuild . tracing { ret = ret . tracing (tracing) ; } <span class="kw">if let </span><span class="prelude-val">Some </span>(features) = features { ret = ret . features (features . clone ()) ; } ret } } # [cfg (feature = <span class="string">"deploy"</span>)] <span class="kw">pub use </span>deploy_graph :: * ; <span class="kw">pub mod </span>in_memory_graph { <span class="kw">pub use </span>hydroflow_lang :: graph :: HydroflowGraph ; <span class="kw">pub use super </span>:: { LocalDeploy , Node , ProcessSpec } ; <span class="kw">pub use crate </span>:: deploy :: in_memory_graph :: SingleProcessGraph ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; LocalDeploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>SingleProcessGraph { <span class="kw">type </span>Process = SingleNode ; <span class="kw">type </span>Cluster = SingleNode ; <span class="kw">type </span>ExternalProcess = SingleNode ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>GraphId = () ; <span class="kw">fn </span>has_trivial_node () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>trivial_process (_id : usize) -&gt; <span class="self">Self </span>:: Process { SingleNode { } } <span class="kw">fn </span>trivial_cluster (_id : usize) -&gt; <span class="self">Self </span>:: Cluster { SingleNode { } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; ProcessSpec &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (<span class="self">self </span>, _id : usize , _name_hint : &amp; str) -&gt; SingleNode { SingleNode { } } } <span class="kw">pub use crate </span>:: deploy :: in_memory_graph :: SingleNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>SingleNode { <span class="kw">type </span>Port = () ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>InstantiateEnv = () ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) { panic ! () ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, _env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , _meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , _graph : HydroflowGraph , _extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { } } <span class="kw">pub use crate </span>:: deploy :: in_memory_graph :: MultiGraph ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; LocalDeploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>MultiGraph { <span class="kw">type </span>Process = MultiNode ; <span class="kw">type </span>Cluster = MultiNode ; <span class="kw">type </span>ExternalProcess = MultiNode ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>GraphId = usize ; <span class="kw">fn </span>has_trivial_node () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>trivial_process (_id : usize) -&gt; <span class="self">Self </span>:: Process { MultiNode { } } <span class="kw">fn </span>trivial_cluster (_id : usize) -&gt; <span class="self">Self </span>:: Cluster { MultiNode { } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; ProcessSpec &lt; <span class="lifetime">'a </span>, MultiGraph &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (<span class="self">self </span>, _id : usize , _name_hint : &amp; str) -&gt; MultiNode { MultiNode { } } } <span class="kw">pub use crate </span>:: deploy :: in_memory_graph :: MultiNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>MultiNode { <span class="kw">type </span>Port = () ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>InstantiateEnv = () ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) { panic ! () ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, _env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , _meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , _graph : HydroflowGraph , _extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { } } } <span class="kw">pub use </span>in_memory_graph :: * ; <span class="kw">pub use crate </span>:: deploy :: LocalDeploy ; <span class="kw">pub use crate </span>:: deploy :: Deploy ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Deploy &lt; <span class="lifetime">'a </span>, Process = N , Cluster = C , ExternalProcess = E , Meta = M , GraphId = R &gt; , N : Node &lt; Meta = M &gt; , C : Node &lt; Meta = M &gt; , E : Node &lt; Meta = M &gt; , M : Default , R , &gt; LocalDeploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>T { <span class="kw">type </span>Process = N ; <span class="kw">type </span>Cluster = C ; <span class="kw">type </span>ExternalProcess = E ; <span class="kw">type </span>Meta = M ; <span class="kw">type </span>GraphId = R ; <span class="kw">fn </span>has_trivial_node () -&gt; bool { &lt; T <span class="kw">as </span>Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; :: has_trivial_node () } <span class="kw">fn </span>trivial_process (id : usize) -&gt; <span class="self">Self </span>:: Process { &lt; T <span class="kw">as </span>Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; :: trivial_process (id) } <span class="kw">fn </span>trivial_cluster (id : usize) -&gt; <span class="self">Self </span>:: Cluster { &lt; T <span class="kw">as </span>Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; :: trivail_cluster (id) } } <span class="kw">pub use crate </span>:: deploy :: ProcessSpec ; <span class="kw">pub use crate </span>:: deploy :: ClusterSpec ; <span class="kw">pub use crate </span>:: deploy :: ExternalSpec ; <span class="kw">pub use crate </span>:: deploy :: Node ; <span class="kw">pub use crate </span>:: deploy :: RegisterPort ; } <span class="kw">pub use </span>deploy :: { ClusterSpec , Deploy , ProcessSpec } ; <span class="kw">pub mod </span>cycle { <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use crate </span>:: builder :: FlowState ; <span class="kw">pub use crate </span>:: location :: { Location , LocationId } ; <span class="kw">pub use crate </span>:: { NoTick , Tick } ; <span class="kw">pub use crate </span>:: cycle :: CycleComplete ; <span class="kw">pub use crate </span>:: cycle :: CycleCollection ; <span class="kw">pub use crate </span>:: cycle :: CycleCollectionWithInitial ; <span class="kw">pub use crate </span>:: cycle :: HfCycle ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, S : CycleComplete &lt; <span class="lifetime">'a </span>, NoTick &gt; &gt; HfCycle &lt; <span class="lifetime">'a </span>, NoTick , S &gt; { <span class="kw">pub fn </span>complete (<span class="self">self </span>, stream : S) { <span class="kw">let </span>ident = <span class="self">self </span>. ident ; S :: complete (stream , ident) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, S : CycleComplete &lt; <span class="lifetime">'a </span>, Tick &gt; &gt; HfCycle &lt; <span class="lifetime">'a </span>, Tick , S &gt; { <span class="kw">pub fn </span>complete_next_tick (<span class="self">self </span>, stream : S) { <span class="kw">let </span>ident = <span class="self">self </span>. ident ; S :: complete (stream , ident) } } } <span class="kw">pub use </span>cycle :: HfCycle ; <span class="kw">pub mod </span>builder { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: collections :: HashMap ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>internal :: TokenStream ; <span class="kw">pub use </span>proc_macro2 :: Span ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>runtime_support :: FreeVariable ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub use super </span>:: staging_util :: get_this_crate ; <span class="kw">pub use crate </span>:: ir :: HfPlusLeaf ; <span class="kw">pub use crate </span>:: location :: { Cluster , ExternalProcess , Process } ; <span class="kw">pub use crate </span>:: { ClusterId , RuntimeContext } ; <span class="kw">pub mod </span>built { <span class="kw">pub use </span>std :: collections :: { BTreeMap , HashMap } ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>hydroflow_lang :: graph :: { eliminate_extra_unions_tees , HydroflowGraph } ; <span class="kw">pub use super </span>:: deploy :: { DeployFlow , DeployResult } ; <span class="kw">pub use crate </span>:: deploy :: { ClusterSpec , Deploy , ExternalSpec , LocalDeploy , ProcessSpec } ; <span class="kw">pub use crate </span>:: ir :: HfPlusLeaf ; <span class="kw">pub use crate </span>:: location :: { Cluster , ExternalProcess , Process } ; <span class="kw">pub use crate </span>:: HfCompiled ; <span class="kw">pub use crate </span>:: builder :: built :: BuiltFlow ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Drop <span class="kw">for </span>BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>drop (&amp; <span class="kw-2">mut </span><span class="self">self</span>) { <span class="kw">if </span>! <span class="self">self </span>. used { panic ! (<span class="string">"Dropped BuiltFlow without instantiating, you may have forgotten to call `compile` or `deploy`."</span>) ; } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">pub fn </span>ir (&amp; <span class="self">self</span>) -&gt; &amp; Vec &lt; HfPlusLeaf &gt; { &amp; <span class="self">self </span>. ir } <span class="kw">pub fn </span>optimize_with (<span class="kw-2">mut </span><span class="self">self </span>, f : <span class="kw">impl </span>FnOnce (Vec &lt; HfPlusLeaf &gt;) -&gt; Vec &lt; HfPlusLeaf &gt; ,) -&gt; BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="self">self </span>. used = <span class="bool-val">true </span>; BuiltFlow { ir : f (std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. ir)) , processes : std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. processes) , clusters : std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. clusters) , used : <span class="bool-val">false </span>, _phantom : PhantomData , } } } <span class="kw">pub fn </span>build_inner (ir : &amp; <span class="kw-2">mut </span>Vec &lt; HfPlusLeaf &gt;) -&gt; BTreeMap &lt; usize , HydroflowGraph &gt; { <span class="kw">let </span><span class="kw-2">mut </span>builders = BTreeMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>built_tees = HashMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>next_stmt_id = <span class="number">0 </span>; <span class="kw">for </span>leaf <span class="kw">in </span>ir { leaf . emit (&amp; <span class="kw-2">mut </span>builders , &amp; <span class="kw-2">mut </span>built_tees , &amp; <span class="kw-2">mut </span>next_stmt_id) ; } builders . into_iter () . map (| (k , v) | { <span class="kw">let </span>(<span class="kw-2">mut </span>flat_graph , <span class="kw">_ </span>, <span class="kw">_</span>) = v . build () ; eliminate_extra_unions_tees (&amp; <span class="kw-2">mut </span>flat_graph) ; (k , flat_graph) }) . collect () } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">pub fn </span>compile_no_network &lt; D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="kw-2">mut </span><span class="self">self</span>) -&gt; HfCompiled &lt; <span class="lifetime">'a </span>, D :: GraphId &gt; { <span class="self">self </span>. used = <span class="bool-val">true </span>; HfCompiled { hydroflow_ir : build_inner (&amp; <span class="kw-2">mut </span><span class="self">self </span>. ir) , extra_stmts : BTreeMap :: new () , _phantom : PhantomData , } } <span class="kw">pub fn </span>with_default_optimize (<span class="self">self</span>) -&gt; BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="self">self </span>. optimize_with (<span class="kw">crate </span>:: persist_pullup :: persist_pullup) } <span class="kw">fn </span>into_deploy &lt; D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="kw-2">mut </span><span class="self">self</span>) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. used = <span class="bool-val">true </span>; <span class="kw">let </span>processes = <span class="kw">if </span>D :: has_trivial_node () { <span class="self">self </span>. processes . iter () . map (| id | (* id , D :: trivial_process (* id))) . collect () } <span class="kw">else </span>{ HashMap :: new () } ; <span class="kw">let </span>clusters = <span class="kw">if </span>D :: has_trivial_node () { <span class="self">self </span>. clusters . iter () . map (| id | (* id , D :: trivial_cluster (* id))) . collect () } <span class="kw">else </span>{ HashMap :: new () } ; DeployFlow { ir : std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. ir) , nodes : processes , clusters , externals : HashMap :: new () , used : <span class="bool-val">false </span>, _phantom : PhantomData , } } <span class="kw">pub fn </span>with_process &lt; P , D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, process : &amp; Process &lt; P &gt; , spec : <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. into_deploy () . with_process (process , spec) } <span class="kw">pub fn </span>with_external &lt; P , D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, process : &amp; ExternalProcess &lt; P &gt; , spec : <span class="kw">impl </span>ExternalSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. into_deploy () . with_external (process , spec) } <span class="kw">pub fn </span>with_cluster &lt; C , D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, cluster : &amp; Cluster &lt; C &gt; , spec : <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. into_deploy () . with_cluster (cluster , spec) } <span class="kw">pub fn </span>compile &lt; D : Deploy &lt; <span class="lifetime">'a </span>&gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, env : &amp; D :: CompileEnv) -&gt; HfCompiled &lt; <span class="lifetime">'a </span>, D :: GraphId &gt; { <span class="self">self </span>. into_deploy :: &lt; D &gt; () . compile (env) } <span class="kw">pub fn </span>deploy &lt; D : Deploy &lt; <span class="lifetime">'a </span>, CompileEnv = () &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, env : &amp; <span class="kw-2">mut </span>D :: InstantiateEnv ,) -&gt; DeployResult &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. into_deploy :: &lt; D &gt; () . deploy (env) } } } <span class="kw">pub mod </span>deploy { <span class="kw">pub use </span>std :: collections :: { BTreeMap , HashMap } ; <span class="kw">pub use </span>std :: io :: Error ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: pin :: Pin ; <span class="kw">pub use </span>hydroflow :: bytes :: Bytes ; <span class="kw">pub use </span>hydroflow :: futures :: { Sink , Stream } ; <span class="kw">pub use </span>proc_macro2 :: Span ; <span class="kw">pub use </span>serde :: de :: DeserializeOwned ; <span class="kw">pub use </span>serde :: Serialize ; <span class="kw">pub use </span>stageleft :: Quoted ; <span class="kw">pub use super </span>:: built :: build_inner ; <span class="kw">pub use crate </span>:: deploy :: { ExternalSpec , LocalDeploy , Node , RegisterPort } ; <span class="kw">pub use crate </span>:: ir :: HfPlusLeaf ; <span class="kw">pub use crate </span>:: location :: { ExternalBincodeSink , ExternalBincodeStream , ExternalBytesPort , ExternalProcess , Location , LocationId , } ; <span class="kw">pub use crate </span>:: { Cluster , ClusterSpec , Deploy , HfCompiled , Process , ProcessSpec } ; <span class="kw">pub use crate </span>:: builder :: deploy :: DeployFlow ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; Drop <span class="kw">for </span>DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">fn </span>drop (&amp; <span class="kw-2">mut </span><span class="self">self</span>) { <span class="kw">if </span>! <span class="self">self </span>. used { panic ! (<span class="string">"Dropped DeployFlow without instantiating, you may have forgotten to call `compile` or `deploy`."</span>) ; } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">pub fn </span>with_process &lt; P &gt; (<span class="kw-2">mut </span><span class="self">self </span>, process : &amp; Process &lt; P &gt; , spec : <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt;) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>tag_name = std :: any :: type_name :: &lt; P &gt; () . to_string () ; <span class="self">self </span>. nodes . insert (process . id , spec . build (process . id , &amp; tag_name)) ; <span class="self">self </span>} <span class="kw">pub fn </span>with_external &lt; P &gt; (<span class="kw-2">mut </span><span class="self">self </span>, process : &amp; ExternalProcess &lt; P &gt; , spec : <span class="kw">impl </span>ExternalSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>tag_name = std :: any :: type_name :: &lt; P &gt; () . to_string () ; <span class="self">self </span>. externals . insert (process . id , spec . build (process . id , &amp; tag_name)) ; <span class="self">self </span>} <span class="kw">pub fn </span>with_cluster &lt; C &gt; (<span class="kw-2">mut </span><span class="self">self </span>, cluster : &amp; Cluster &lt; C &gt; , spec : <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt;) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>tag_name = std :: any :: type_name :: &lt; C &gt; () . to_string () ; <span class="self">self </span>. clusters . insert (cluster . id , spec . build (cluster . id , &amp; tag_name)) ; <span class="self">self </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">pub fn </span>compile (<span class="kw-2">mut </span><span class="self">self </span>, env : &amp; D :: CompileEnv) -&gt; HfCompiled &lt; <span class="lifetime">'a </span>, D :: GraphId &gt; { <span class="self">self </span>. used = <span class="bool-val">true </span>; <span class="kw">let </span><span class="kw-2">mut </span>seen_tees : HashMap &lt; <span class="kw">_ </span>, <span class="kw">_ </span>&gt; = HashMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>flow_state_networked : Vec &lt; HfPlusLeaf &gt; = std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. ir) . into_iter () . map (| leaf | { leaf . compile_network :: &lt; D &gt; (env , &amp; <span class="kw-2">mut </span>seen_tees , &amp; <span class="self">self </span>. nodes , &amp; <span class="self">self </span>. clusters , &amp; <span class="self">self </span>. externals ,) }) . collect () ; <span class="kw">let </span>extra_stmts = <span class="self">self </span>. extra_stmts (env) ; HfCompiled { hydroflow_ir : build_inner (&amp; <span class="kw-2">mut </span>flow_state_networked) , extra_stmts , _phantom : PhantomData , } } <span class="kw">fn </span>extra_stmts (&amp; <span class="self">self </span>, env : &amp; &lt; D <span class="kw">as </span>Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; :: CompileEnv) -&gt; BTreeMap &lt; usize , Vec &lt; syn :: Stmt &gt; &gt; { <span class="kw">let </span>all_locations_count = <span class="self">self </span>. nodes . len () + <span class="self">self </span>. clusters . len () ; <span class="kw">let </span><span class="kw-2">mut </span>extra_stmts : BTreeMap &lt; usize , Vec &lt; syn :: Stmt &gt; &gt; = BTreeMap :: new () ; <span class="kw">for </span>&amp; c_id <span class="kw">in </span><span class="self">self </span>. clusters . keys () { <span class="kw">let </span>self_id_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"__hydroflow_plus_cluster_self_id_{}" </span>, c_id) , Span :: call_site () ,) ; <span class="kw">let </span>self_id_expr = D :: cluster_self_id (env) . splice_untyped () ; extra_stmts . entry (c_id) . or_default () . push (syn :: parse_quote ! { <span class="kw">let </span># self_id_ident = # self_id_expr ; }) ; <span class="kw">for </span>other_location <span class="kw">in </span><span class="number">0 </span>.. all_locations_count { <span class="kw">let </span>other_id_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"__hydroflow_plus_cluster_ids_{}" </span>, c_id) , Span :: call_site () ,) ; <span class="kw">let </span>other_id_expr = D :: cluster_ids (env , c_id) . splice_untyped () ; extra_stmts . entry (other_location) . or_default () . push (syn :: parse_quote ! { <span class="kw">let </span># other_id_ident = # other_id_expr ; }) ; } } extra_stmts } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>, CompileEnv = () &gt; &gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { # [must_use] <span class="kw">pub fn </span>deploy (<span class="kw-2">mut </span><span class="self">self </span>, env : &amp; <span class="kw-2">mut </span>D :: InstantiateEnv) -&gt; DeployResult &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. used = <span class="bool-val">true </span>; <span class="kw">let </span><span class="kw-2">mut </span>seen_tees_instantiate : HashMap &lt; <span class="kw">_ </span>, <span class="kw">_ </span>&gt; = HashMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>flow_state_networked : Vec &lt; HfPlusLeaf &gt; = std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. ir) . into_iter () . map (| leaf | { leaf . compile_network :: &lt; D &gt; (&amp; () , &amp; <span class="kw-2">mut </span>seen_tees_instantiate , &amp; <span class="self">self </span>. nodes , &amp; <span class="self">self </span>. clusters , &amp; <span class="self">self </span>. externals ,) }) . collect () ; <span class="kw">let </span><span class="kw-2">mut </span>compiled = build_inner (&amp; <span class="kw-2">mut </span>flow_state_networked) ; <span class="kw">let </span><span class="kw-2">mut </span>extra_stmts = <span class="self">self </span>. extra_stmts (&amp; ()) ; <span class="kw">let </span><span class="kw-2">mut </span>meta = D :: Meta :: default () ; <span class="kw">let </span>(<span class="kw-2">mut </span>processes , <span class="kw-2">mut </span>clusters , <span class="kw-2">mut </span>externals) = (std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. nodes) . into_iter () . map (| (node_id , node) | { node . instantiate (env , &amp; <span class="kw-2">mut </span>meta , compiled . remove (&amp; node_id) . unwrap () , extra_stmts . remove (&amp; node_id) . unwrap_or_default () ,) ; (node_id , node) }) . collect :: &lt; HashMap &lt; <span class="kw">_ </span>, <span class="kw">_ </span>&gt; &gt; () , std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. clusters) . into_iter () . map (| (cluster_id , cluster) | { cluster . instantiate (env , &amp; <span class="kw-2">mut </span>meta , compiled . remove (&amp; cluster_id) . unwrap () , extra_stmts . remove (&amp; cluster_id) . unwrap_or_default () ,) ; (cluster_id , cluster) }) . collect :: &lt; HashMap &lt; <span class="kw">_ </span>, <span class="kw">_ </span>&gt; &gt; () , std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. externals) . into_iter () . map (| (external_id , external) | { external . instantiate (env , &amp; <span class="kw-2">mut </span>meta , compiled . remove (&amp; external_id) . unwrap () , extra_stmts . remove (&amp; external_id) . unwrap_or_default () ,) ; (external_id , external) }) . collect :: &lt; HashMap &lt; <span class="kw">_ </span>, <span class="kw">_ </span>&gt; &gt; () ,) ; <span class="kw">for </span>node <span class="kw">in </span>processes . values_mut () { node . update_meta (&amp; meta) ; } <span class="kw">for </span>cluster <span class="kw">in </span>clusters . values_mut () { cluster . update_meta (&amp; meta) ; } <span class="kw">for </span>external <span class="kw">in </span>externals . values_mut () { external . update_meta (&amp; meta) ; } <span class="kw">let </span><span class="kw-2">mut </span>seen_tees_connect = HashMap :: new () ; <span class="kw">for </span>leaf <span class="kw">in </span>flow_state_networked { leaf . connect_network (&amp; <span class="kw-2">mut </span>seen_tees_connect) ; } DeployResult { processes , clusters , externals , } } } <span class="kw">pub use crate </span>:: builder :: deploy :: DeployResult ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; DeployResult &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">pub fn </span>get_process &lt; P &gt; (&amp; <span class="self">self </span>, p : &amp; Process &lt; P &gt;) -&gt; &amp; D :: Process { <span class="kw">let </span>id = <span class="kw">match </span>p . id () { LocationId :: Process (id) =&gt; id , <span class="kw">_ </span>=&gt; panic ! (<span class="string">"Process ID expected"</span>) , } ; <span class="self">self </span>. processes . get (&amp; id) . unwrap () } <span class="kw">pub fn </span>get_cluster &lt; C &gt; (&amp; <span class="self">self </span>, c : &amp; Cluster &lt; <span class="lifetime">'a </span>, C &gt;) -&gt; &amp; D :: Cluster { <span class="kw">let </span>id = <span class="kw">match </span>c . id () { LocationId :: Cluster (id) =&gt; id , <span class="kw">_ </span>=&gt; panic ! (<span class="string">"Cluster ID expected"</span>) , } ; <span class="self">self </span>. clusters . get (&amp; id) . unwrap () } <span class="kw">pub fn </span>get_external &lt; P &gt; (&amp; <span class="self">self </span>, p : &amp; ExternalProcess &lt; P &gt;) -&gt; &amp; D :: ExternalProcess { <span class="self">self </span>. externals . get (&amp; p . id) . unwrap () } <span class="kw">pub fn </span>raw_port (&amp; <span class="self">self </span>, port : ExternalBytesPort) -&gt; D :: ExternalRawPort { <span class="self">self </span>. externals . get (&amp; port . process_id) . unwrap () . raw_port (port . port_id) } <span class="kw">pub async fn </span>connect_sink_bytes (&amp; <span class="self">self </span>, port : ExternalBytesPort ,) -&gt; Pin &lt; Box &lt; <span class="kw">dyn </span>Sink &lt; Bytes , Error = Error &gt; &gt; &gt; { <span class="self">self </span>. externals . get (&amp; port . process_id) . unwrap () . as_bytes_sink (port . port_id) . <span class="kw">await </span>} <span class="kw">pub async fn </span>connect_sink_bincode &lt; T : Serialize + DeserializeOwned + <span class="lifetime">'static </span>&gt; (&amp; <span class="self">self </span>, port : ExternalBincodeSink &lt; T &gt; ,) -&gt; Pin &lt; Box &lt; <span class="kw">dyn </span>Sink &lt; T , Error = Error &gt; &gt; &gt; { <span class="self">self </span>. externals . get (&amp; port . process_id) . unwrap () . as_bincode_sink (port . port_id) . <span class="kw">await </span>} <span class="kw">pub async fn </span>connect_source_bytes (&amp; <span class="self">self </span>, port : ExternalBytesPort ,) -&gt; Pin &lt; Box &lt; <span class="kw">dyn </span>Stream &lt; Item = Bytes &gt; &gt; &gt; { <span class="self">self </span>. externals . get (&amp; port . process_id) . unwrap () . as_bytes_source (port . port_id) . <span class="kw">await </span>} <span class="kw">pub async fn </span>connect_source_bincode &lt; T : Serialize + DeserializeOwned + <span class="lifetime">'static </span>&gt; (&amp; <span class="self">self </span>, port : ExternalBincodeStream &lt; T &gt; ,) -&gt; Pin &lt; Box &lt; <span class="kw">dyn </span>Stream &lt; Item = T &gt; &gt; &gt; { <span class="self">self </span>. externals . get (&amp; port . process_id) . unwrap () . as_bincode_source (port . port_id) . <span class="kw">await </span>} } } <span class="kw">pub use crate </span>:: builder :: FlowStateInner ; <span class="kw">pub type </span>FlowState = Rc &lt; RefCell &lt; FlowStateInner &gt; &gt; ; <span class="kw">pub use crate </span>:: builder :: ClusterIds ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C &gt; Clone <span class="kw">for </span>ClusterIds &lt; <span class="lifetime">'a </span>, C &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ * <span class="self">self </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C &gt; Copy <span class="kw">for </span>ClusterIds &lt; <span class="lifetime">'a </span>, C &gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C &gt; FreeVariable &lt; &amp; <span class="lifetime">'a </span>Vec &lt; ClusterId &lt; C &gt; &gt; &gt; <span class="kw">for </span>ClusterIds &lt; <span class="lifetime">'a </span>, C &gt; { <span class="kw">fn </span>to_tokens (<span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) <span class="kw">where </span><span class="self">Self </span>: Sized , { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">"__hydroflow_plus_cluster_ids_{}" </span>, <span class="self">self </span>. id) , Span :: call_site () ,) ; <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span>c_type = quote_type :: &lt; C &gt; () ; (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(quote ! { <span class="kw">unsafe </span>{ :: std :: mem :: transmute ::&lt; <span class="kw">_ </span>, <span class="kw-2">&amp;</span>:: std :: vec :: Vec &lt;# root :: ClusterId &lt;# c_type &gt;&gt;&gt; (# ident) } } ,) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C &gt; Quoted &lt; <span class="lifetime">'a </span>, &amp; <span class="lifetime">'a </span>Vec &lt; ClusterId &lt; C &gt; &gt; &gt; <span class="kw">for </span>ClusterIds &lt; <span class="lifetime">'a </span>, C &gt; { } <span class="kw">pub struct </span>ClusterSelfId &lt; <span class="lifetime">'a </span>, C &gt; { <span class="kw">pub </span>id : usize , <span class="kw">pub </span>_phantom : PhantomData &lt; &amp; <span class="lifetime">'a </span><span class="kw-2">mut </span>&amp; <span class="lifetime">'a </span>C &gt; , } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C &gt; Clone <span class="kw">for </span>ClusterSelfId &lt; <span class="lifetime">'a </span>, C &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ * <span class="self">self </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C &gt; Copy <span class="kw">for </span>ClusterSelfId &lt; <span class="lifetime">'a </span>, C &gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C &gt; FreeVariable &lt; ClusterId &lt; C &gt; &gt; <span class="kw">for </span>ClusterSelfId &lt; <span class="lifetime">'a </span>, C &gt; { <span class="kw">fn </span>to_tokens (<span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) <span class="kw">where </span><span class="self">Self </span>: Sized , { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">"__hydroflow_plus_cluster_self_id_{}" </span>, <span class="self">self </span>. id) , Span :: call_site () ,) ; <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span>c_type : syn :: Type = quote_type :: &lt; C &gt; () ; (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(quote ! { # root :: ClusterId ::&lt;# c_type &gt;:: from_raw (# ident) }) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C &gt; Quoted &lt; <span class="lifetime">'a </span>, ClusterId &lt; C &gt; &gt; <span class="kw">for </span>ClusterSelfId &lt; <span class="lifetime">'a </span>, C &gt; { } <span class="kw">pub use crate </span>:: builder :: FlowBuilder ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Drop <span class="kw">for </span>FlowBuilder &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>drop (&amp; <span class="kw-2">mut </span><span class="self">self</span>) { <span class="kw">if </span>! <span class="self">self </span>. finalized { panic ! (<span class="string">"Dropped FlowBuilder without finalizing, you may have forgotten to call `with_default_optimize`, `optimize_with`, or `finalize`."</span>) ; } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; QuotedContext <span class="kw">for </span>FlowBuilder &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>create () -&gt; <span class="self">Self </span>{ FlowBuilder :: new () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FlowBuilder &lt; <span class="lifetime">'a </span>&gt; { # [expect (clippy :: new_without_default , reason = <span class="string">"call `new` explicitly, not `default`"</span>)] <span class="kw">pub fn </span>new () -&gt; FlowBuilder &lt; <span class="lifetime">'a </span>&gt; { FlowBuilder { flow_state : Rc :: new (RefCell :: new (FlowStateInner { leaves : <span class="prelude-val">Some </span>(vec ! []) , next_external_out : <span class="number">0 </span>, cycle_counts : HashMap :: new () , })) , nodes : RefCell :: new (vec ! []) , clusters : RefCell :: new (vec ! []) , next_node_id : RefCell :: new (<span class="number">0</span>) , finalized : <span class="bool-val">false </span>, _phantom : PhantomData , } } <span class="kw">pub fn </span>finalize (<span class="kw-2">mut </span><span class="self">self</span>) -&gt; built :: BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="self">self </span>. finalized = <span class="bool-val">true </span>; built :: BuiltFlow { ir : <span class="self">self </span>. flow_state . borrow_mut () . leaves . take () . unwrap () , processes : <span class="self">self </span>. nodes . replace (vec ! []) , clusters : <span class="self">self </span>. clusters . replace (vec ! []) , used : <span class="bool-val">false </span>, _phantom : PhantomData , } } <span class="kw">pub fn </span>with_default_optimize (<span class="self">self</span>) -&gt; built :: BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="self">self </span>. finalize () . with_default_optimize () } <span class="kw">pub fn </span>optimize_with (<span class="self">self </span>, f : <span class="kw">impl </span>FnOnce (Vec &lt; HfPlusLeaf &gt;) -&gt; Vec &lt; HfPlusLeaf &gt; ,) -&gt; built :: BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="self">self </span>. finalize () . optimize_with (f) } <span class="kw">pub fn </span>flow_state (&amp; <span class="self">self</span>) -&gt; &amp; FlowState { &amp; <span class="self">self </span>. flow_state } <span class="kw">pub fn </span>process &lt; P &gt; (&amp; <span class="self">self</span>) -&gt; Process &lt; <span class="lifetime">'a </span>, P &gt; { <span class="kw">let </span><span class="kw-2">mut </span>next_node_id = <span class="self">self </span>. next_node_id . borrow_mut () ; <span class="kw">let </span>id = * next_node_id ; * next_node_id += <span class="number">1 </span>; <span class="self">self </span>. nodes . borrow_mut () . push (id) ; Process { id , flow_state : <span class="self">self </span>. flow_state () . clone () , _phantom : PhantomData , } } <span class="kw">pub fn </span>external_process &lt; P &gt; (&amp; <span class="self">self</span>) -&gt; ExternalProcess &lt; <span class="lifetime">'a </span>, P &gt; { <span class="kw">let </span><span class="kw-2">mut </span>next_node_id = <span class="self">self </span>. next_node_id . borrow_mut () ; <span class="kw">let </span>id = * next_node_id ; * next_node_id += <span class="number">1 </span>; <span class="self">self </span>. nodes . borrow_mut () . push (id) ; ExternalProcess { id , flow_state : <span class="self">self </span>. flow_state () . clone () , _phantom : PhantomData , } } <span class="kw">pub fn </span>cluster &lt; C &gt; (&amp; <span class="self">self</span>) -&gt; Cluster &lt; <span class="lifetime">'a </span>, C &gt; { <span class="kw">let </span><span class="kw-2">mut </span>next_node_id = <span class="self">self </span>. next_node_id . borrow_mut () ; <span class="kw">let </span>id = * next_node_id ; * next_node_id += <span class="number">1 </span>; <span class="self">self </span>. clusters . borrow_mut () . push (id) ; Cluster { id , flow_state : <span class="self">self </span>. flow_state () . clone () , _phantom : PhantomData , } } <span class="kw">pub fn </span>runtime_context (&amp; <span class="self">self</span>) -&gt; RuntimeContext &lt; <span class="lifetime">'a </span>&gt; { RuntimeContext { _phantom : PhantomData , } } } } <span class="kw">pub use </span>builder :: FlowBuilder ; <span class="kw">pub mod </span>ir { <span class="kw">pub use </span>core :: panic ; <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: collections :: { BTreeMap , HashMap } ; <span class="kw">pub use </span>std :: fmt :: Debug ; <span class="kw">pub use </span>std :: ops :: Deref ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>hydroflow_lang :: graph :: FlatGraphBuilder ; <span class="kw">pub use </span>hydroflow_lang :: parse :: Pipeline ; <span class="kw">pub use </span>proc_macro2 :: { Span , TokenStream } ; <span class="kw">pub use </span>quote :: ToTokens ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use crate </span>:: deploy :: { Deploy , RegisterPort } ; <span class="kw">pub use crate </span>:: location :: LocationId ; <span class="kw">pub use crate </span>:: ir :: DebugExpr ; # [cfg (stageleft_macro)] <span class="kw">impl </span>From &lt; syn :: Expr &gt; <span class="kw">for </span>DebugExpr { <span class="kw">fn </span>from (expr : syn :: Expr) -&gt; DebugExpr { DebugExpr (expr) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>Deref <span class="kw">for </span>DebugExpr { <span class="kw">type </span>Target = syn :: Expr ; <span class="kw">fn </span>deref (&amp; <span class="self">self</span>) -&gt; &amp; <span class="self">Self </span>:: Target { &amp; <span class="self">self </span>. <span class="number">0 </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>ToTokens <span class="kw">for </span>DebugExpr { <span class="kw">fn </span>to_tokens (&amp; <span class="self">self </span>, tokens : &amp; <span class="kw-2">mut </span>TokenStream) { <span class="self">self </span>. <span class="number">0 </span>. to_tokens (tokens) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>Debug <span class="kw">for </span>DebugExpr { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"{}" </span>, <span class="self">self </span>. <span class="number">0 </span>. to_token_stream ()) } } <span class="kw">pub use crate </span>:: ir :: DebugInstantiate ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Debug <span class="kw">for </span>DebugInstantiate { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"&lt;network instantiate&gt;"</span>) } } <span class="kw">pub use crate </span>:: ir :: DebugPipelineFn ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Debug <span class="kw">for </span>DebugPipelineFn { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"&lt;function&gt;"</span>) } } <span class="kw">pub use crate </span>:: ir :: HfPlusSource ; <span class="kw">pub use crate </span>:: ir :: HfPlusLeaf ; # [cfg (stageleft_macro)] <span class="kw">impl </span>HfPlusLeaf { <span class="kw">pub fn </span>compile_network &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, compile_env : &amp; D :: CompileEnv , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees , nodes : &amp; HashMap &lt; usize , D :: Process &gt; , clusters : &amp; HashMap &lt; usize , D :: Cluster &gt; , externals : &amp; HashMap &lt; usize , D :: ExternalProcess &gt; ,) -&gt; HfPlusLeaf { <span class="self">self </span>. transform_children (| n , s | { n . compile_network :: &lt; D &gt; (compile_env , s , nodes , clusters , externals) ; } , seen_tees ,) } <span class="kw">pub fn </span>connect_network (<span class="self">self </span>, seen_tees : &amp; <span class="kw-2">mut </span>SeenTees) -&gt; HfPlusLeaf { <span class="self">self </span>. transform_children (| n , s | { n . connect_network (s) ; } , seen_tees ,) } <span class="kw">pub fn </span>transform_children (<span class="self">self </span>, <span class="kw-2">mut </span>transform : <span class="kw">impl </span>FnMut (&amp; <span class="kw-2">mut </span>HfPlusNode , &amp; <span class="kw-2">mut </span>SeenTees) , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees ,) -&gt; HfPlusLeaf { <span class="kw">match </span><span class="self">self </span>{ HfPlusLeaf :: ForEach { f , <span class="kw-2">mut </span>input } =&gt; { transform (&amp; <span class="kw-2">mut </span>input , seen_tees) ; HfPlusLeaf :: ForEach { f , input } } HfPlusLeaf :: DestSink { sink , <span class="kw-2">mut </span>input } =&gt; { transform (&amp; <span class="kw-2">mut </span>input , seen_tees) ; HfPlusLeaf :: DestSink { sink , input } } HfPlusLeaf :: CycleSink { ident , location_kind , <span class="kw-2">mut </span>input , } =&gt; { transform (&amp; <span class="kw-2">mut </span>input , seen_tees) ; HfPlusLeaf :: CycleSink { ident , location_kind , input , } } } } <span class="kw">pub fn </span>emit (&amp; <span class="self">self </span>, graph_builders : &amp; <span class="kw-2">mut </span>BTreeMap &lt; usize , FlatGraphBuilder &gt; , built_tees : &amp; <span class="kw-2">mut </span>HashMap &lt; * <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , (syn :: Ident , usize) &gt; , next_stmt_id : &amp; <span class="kw-2">mut </span>usize ,) { <span class="kw">match </span><span class="self">self </span>{ HfPlusLeaf :: ForEach { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; graph_builders . entry (input_location_id) . or_default () . add_statement (parse_quote ! { # input_ident -&gt; for_each (# f) ; }) ; } HfPlusLeaf :: DestSink { sink , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; graph_builders . entry (input_location_id) . or_default () . add_statement (parse_quote ! { # input_ident -&gt; dest_sink (# sink) ; }) ; } HfPlusLeaf :: CycleSink { ident , location_kind , input , } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>location_id = <span class="kw">match </span>location_kind { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , LocationId :: ExternalProcess (<span class="kw">_</span>) =&gt; panic ! () , } ; assert_eq ! (input_location_id , * location_id , <span class="string">"cycle_sink location mismatch"</span>) ; graph_builders . entry (* location_id) . or_default () . add_statement (parse_quote ! { # ident = # input_ident ; }) ; } } } } <span class="kw">type </span>PrintedTees = RefCell &lt; <span class="prelude-ty">Option </span>&lt; (usize , HashMap &lt; * <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , usize &gt;) &gt; &gt; ; thread_local ! { <span class="kw">static </span>PRINTED_TEES : PrintedTees = <span class="kw">const </span>{ RefCell :: new (<span class="prelude-val">None</span>) } ; } <span class="kw">pub fn </span>dbg_dedup_tee &lt; T &gt; (f : <span class="kw">impl </span>FnOnce () -&gt; T) -&gt; T { PRINTED_TEES . with (| printed_tees | { <span class="kw">let </span><span class="kw-2">mut </span>printed_tees_mut = printed_tees . borrow_mut () ; * printed_tees_mut = <span class="prelude-val">Some </span>((<span class="number">0 </span>, HashMap :: new ())) ; drop (printed_tees_mut) ; <span class="kw">let </span>ret = f () ; <span class="kw">let </span><span class="kw-2">mut </span>printed_tees_mut = printed_tees . borrow_mut () ; * printed_tees_mut = <span class="prelude-val">None </span>; ret }) } <span class="kw">pub use crate </span>:: ir :: TeeNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Debug <span class="kw">for </span>TeeNode { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ PRINTED_TEES . with (| printed_tees | { <span class="kw">let </span><span class="kw-2">mut </span>printed_tees_mut_borrow = printed_tees . borrow_mut () ; <span class="kw">let </span>printed_tees_mut = printed_tees_mut_borrow . as_mut () ; <span class="kw">if let </span><span class="prelude-val">Some </span>(printed_tees_mut) = printed_tees_mut { <span class="kw">if let </span><span class="prelude-val">Some </span>(existing) = printed_tees_mut . <span class="number">1 </span>. get (&amp; (<span class="self">self </span>. <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt;)) { write ! (f , <span class="string">"&lt;tee {}&gt;" </span>, existing) } <span class="kw">else </span>{ <span class="kw">let </span>next_id = printed_tees_mut . <span class="number">0 </span>; printed_tees_mut . <span class="number">0 </span>+= <span class="number">1 </span>; printed_tees_mut . <span class="number">1 </span>. insert (<span class="self">self </span>. <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , next_id) ; drop (printed_tees_mut_borrow) ; write ! (f , <span class="string">"&lt;tee {}&gt;: " </span>, next_id) <span class="question-mark">? </span>; Debug :: fmt (&amp; <span class="self">self </span>. <span class="number">0 </span>. borrow () , f) } } <span class="kw">else </span>{ drop (printed_tees_mut_borrow) ; write ! (f , <span class="string">"&lt;tee&gt;: "</span>) <span class="question-mark">? </span>; Debug :: fmt (&amp; <span class="self">self </span>. <span class="number">0 </span>. borrow () , f) } }) } } <span class="kw">pub use crate </span>:: ir :: HfPlusNode ; <span class="kw">pub type </span>SeenTees = HashMap &lt; * <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , Rc &lt; RefCell &lt; HfPlusNode &gt; &gt; &gt; ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; HfPlusNode { <span class="kw">pub fn </span>compile_network &lt; D : Deploy &lt; <span class="lifetime">'a </span>&gt; + <span class="lifetime">'a </span>&gt; (&amp; <span class="kw-2">mut </span><span class="self">self </span>, compile_env : &amp; D :: CompileEnv , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees , nodes : &amp; HashMap &lt; usize , D :: Process &gt; , clusters : &amp; HashMap &lt; usize , D :: Cluster &gt; , externals : &amp; HashMap &lt; usize , D :: ExternalProcess &gt; ,) { <span class="self">self </span>. transform_children (| n , s | n . compile_network :: &lt; D &gt; (compile_env , s , nodes , clusters , externals) , seen_tees ,) ; <span class="kw">if let </span>HfPlusNode :: Network { from_location , from_key , to_location , to_key , instantiate_fn , .. } = <span class="self">self </span>{ <span class="kw">let </span>(sink_expr , source_expr , connect_fn) = <span class="kw">match </span>instantiate_fn { DebugInstantiate :: Building () =&gt; instantiate_network :: &lt; D &gt; (from_location , * from_key , to_location , * to_key , nodes , clusters , externals , compile_env ,) , DebugInstantiate :: Finalized (<span class="kw">_ </span>, <span class="kw">_ </span>, <span class="kw">_</span>) =&gt; panic ! (<span class="string">"network already finalized"</span>) , } ; * instantiate_fn = DebugInstantiate :: Finalized (sink_expr , source_expr , <span class="prelude-val">Some </span>(connect_fn)) ; } } <span class="kw">pub fn </span>connect_network (&amp; <span class="kw-2">mut </span><span class="self">self </span>, seen_tees : &amp; <span class="kw-2">mut </span>SeenTees) { <span class="self">self </span>. transform_children (| n , s | n . connect_network (s) , seen_tees) ; <span class="kw">if let </span>HfPlusNode :: Network { instantiate_fn , .. } = <span class="self">self </span>{ <span class="kw">match </span>instantiate_fn { DebugInstantiate :: Building () =&gt; panic ! (<span class="string">"network not built"</span>) , DebugInstantiate :: Finalized (<span class="kw">_ </span>, <span class="kw">_ </span>, connect_fn) =&gt; { connect_fn . take () . unwrap () () ; } } } } <span class="kw">pub fn </span>transform_bottom_up &lt; C &gt; (&amp; <span class="kw-2">mut </span><span class="self">self </span>, <span class="kw-2">mut </span>transform : <span class="kw">impl </span>FnMut (&amp; <span class="kw-2">mut </span>HfPlusNode , &amp; <span class="kw-2">mut </span>C) + Copy , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees , ctx : &amp; <span class="kw-2">mut </span>C ,) { <span class="self">self </span>. transform_children (| n , s | n . transform_bottom_up (transform , s , ctx) , seen_tees) ; transform (<span class="self">self </span>, ctx) } # [inline (always)] <span class="kw">pub fn </span>transform_children (&amp; <span class="kw-2">mut </span><span class="self">self </span>, <span class="kw-2">mut </span>transform : <span class="kw">impl </span>FnMut (&amp; <span class="kw-2">mut </span>HfPlusNode , &amp; <span class="kw-2">mut </span>SeenTees) , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees ,) { <span class="kw">match </span><span class="self">self </span>{ HfPlusNode :: Placeholder =&gt; { panic ! () ; } HfPlusNode :: Source { .. } =&gt; { } HfPlusNode :: CycleSource { .. } =&gt; { } HfPlusNode :: Tee { inner } =&gt; { <span class="kw">if let </span><span class="prelude-val">Some </span>(transformed) = seen_tees . get (&amp; (inner . <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt;)) { * inner = TeeNode (transformed . clone ()) ; } <span class="kw">else </span>{ <span class="kw">let </span>transformed_cell = Rc :: new (RefCell :: new (HfPlusNode :: Placeholder)) ; seen_tees . insert (inner . <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , transformed_cell . clone () ,) ; <span class="kw">let </span><span class="kw-2">mut </span>orig = inner . <span class="number">0 </span>. replace (HfPlusNode :: Placeholder) ; transform (&amp; <span class="kw-2">mut </span>orig , seen_tees) ; * transformed_cell . borrow_mut () = orig ; * inner = TeeNode (transformed_cell) ; } } HfPlusNode :: Persist (inner) =&gt; transform (inner . as_mut () , seen_tees) , HfPlusNode :: Unpersist (inner) =&gt; transform (inner . as_mut () , seen_tees) , HfPlusNode :: Delta (inner) =&gt; transform (inner . as_mut () , seen_tees) , HfPlusNode :: Union (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HfPlusNode :: CrossProduct (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HfPlusNode :: CrossSingleton (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HfPlusNode :: Join (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HfPlusNode :: Difference (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HfPlusNode :: AntiJoin (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HfPlusNode :: Map { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: FlatMap { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Filter { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: FilterMap { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Sort (input) =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: DeferTick (input) =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Enumerate (input) =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Inspect { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Unique (input) =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Fold { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: FoldKeyed { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Reduce { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: ReduceKeyed { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Network { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } } } <span class="kw">pub fn </span>emit (&amp; <span class="self">self </span>, graph_builders : &amp; <span class="kw-2">mut </span>BTreeMap &lt; usize , FlatGraphBuilder &gt; , built_tees : &amp; <span class="kw-2">mut </span>HashMap &lt; * <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , (syn :: Ident , usize) &gt; , next_stmt_id : &amp; <span class="kw-2">mut </span>usize ,) -&gt; (syn :: Ident , usize) { <span class="kw">match </span><span class="self">self </span>{ HfPlusNode :: Placeholder =&gt; { panic ! () } HfPlusNode :: Persist (inner) =&gt; { <span class="kw">let </span>(inner_ident , location) = inner . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>persist_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>persist_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, persist_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (location) . or_default () ; builder . add_statement (parse_quote ! { # persist_ident = # inner_ident -&gt; persist ::&lt;<span class="lifetime">'static </span>&gt; () ; }) ; (persist_ident , location) } HfPlusNode :: Unpersist (<span class="kw">_</span>) =&gt; { panic ! (<span class="string">"Unpersist is a marker node and should have been optimized away. This is likely a compiler bug."</span>) } HfPlusNode :: Delta (inner) =&gt; { <span class="kw">let </span>(inner_ident , location) = inner . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>delta_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>delta_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, delta_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (location) . or_default () ; builder . add_statement (parse_quote ! { # delta_ident = # inner_ident -&gt; multiset_delta () ; }) ; (delta_ident , location) } HfPlusNode :: Source { source , location_kind , } =&gt; { <span class="kw">let </span>location_id = <span class="kw">match </span>location_kind { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , LocationId :: ExternalProcess (id) =&gt; id , } ; <span class="kw">if let </span>HfPlusSource :: ExternalNetwork () = source { (syn :: Ident :: new (<span class="string">"DUMMY" </span>, Span :: call_site ()) , * location_id) } <span class="kw">else </span>{ <span class="kw">let </span>source_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>source_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, source_id) , Span :: call_site ()) ; <span class="kw">let </span>source_stmt = <span class="kw">match </span>source { HfPlusSource :: Stream (expr) =&gt; { parse_quote ! { # source_ident = source_stream (# expr) ; } } HfPlusSource :: ExternalNetwork () =&gt; { unreachable ! () } HfPlusSource :: Iter (expr) =&gt; { parse_quote ! { # source_ident = source_iter (# expr) ; } } HfPlusSource :: Interval (expr) =&gt; { parse_quote ! { # source_ident = source_interval (# expr) ; } } HfPlusSource :: Spin () =&gt; { parse_quote ! { # source_ident = spin () ; } } } ; graph_builders . entry (* location_id) . or_default () . add_statement (source_stmt) ; (source_ident , * location_id) } } HfPlusNode :: CycleSource { ident , location_kind , } =&gt; { <span class="kw">let </span>location_id = <span class="kw">match </span>location_kind { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , LocationId :: ExternalProcess (<span class="kw">_</span>) =&gt; panic ! () , } ; (ident . clone () , * location_id) } HfPlusNode :: Tee { inner } =&gt; { <span class="kw">if let </span><span class="prelude-val">Some </span>(ret) = built_tees . get (&amp; (inner . <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt;)) { ret . clone () } <span class="kw">else </span>{ <span class="kw">let </span>(inner_ident , inner_location_id) = inner . <span class="number">0 </span>. borrow () . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>tee_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>tee_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, tee_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (inner_location_id) . or_default () ; builder . add_statement (parse_quote ! { # tee_ident = # inner_ident -&gt; tee () ; }) ; built_tees . insert (inner . <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , (tee_ident . clone () , inner_location_id) ,) ; (tee_ident , inner_location_id) } } HfPlusNode :: Union (left , right) =&gt; { <span class="kw">let </span>(left_ident , left_location_id) = left . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id) = right . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"union inputs must be in the same location"</span>) ; <span class="kw">let </span>union_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>union_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, union_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; builder . add_statement (parse_quote ! { # union_ident = union () ; }) ; builder . add_statement (parse_quote ! { # left_ident -&gt; [<span class="number">0</span>] # union_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [<span class="number">1</span>] # union_ident ; }) ; (union_ident , left_location_id) } HfPlusNode :: CrossSingleton (left , right) =&gt; { <span class="kw">let </span>(left_ident , left_location_id) = left . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id) = right . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"cross_singleton inputs must be in the same location"</span>) ; <span class="kw">let </span>union_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>cross_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, union_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; builder . add_statement (parse_quote ! { # cross_ident = cross_singleton () ; }) ; builder . add_statement (parse_quote ! { # left_ident -&gt; [input] # cross_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [single] # cross_ident ; }) ; (cross_ident , left_location_id) } HfPlusNode :: CrossProduct (..) | HfPlusNode :: Join (..) =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HfPlusNode :: CrossProduct (..)) { parse_quote ! (cross_join_multiset) } <span class="kw">else </span>{ parse_quote ! (join_multiset) } ; <span class="kw">let </span>(HfPlusNode :: CrossProduct (left , right) | HfPlusNode :: Join (left , right)) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(left_inner , left_was_persist) = <span class="kw">if let </span>HfPlusNode :: Persist (left) = left . as_ref () { (left , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (left , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(right_inner , right_was_persist) = <span class="kw">if let </span>HfPlusNode :: Persist (right) = right . as_ref () { (right , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (right , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(left_ident , left_location_id) = left_inner . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id) = right_inner . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"join / cross product inputs must be in the same location"</span>) ; <span class="kw">let </span>stream_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>stream_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, stream_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; <span class="kw">match </span>(left_was_persist , right_was_persist) { (<span class="bool-val">true </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'static </span>, <span class="lifetime">'static </span>&gt; () ; }) ; } (<span class="bool-val">true </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'static </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; } (<span class="bool-val">false </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'static </span>&gt; () ; }) ; } (<span class="bool-val">false </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; } } ; builder . add_statement (parse_quote ! { # left_ident -&gt; [<span class="number">0</span>] # stream_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [<span class="number">1</span>] # stream_ident ; }) ; (stream_ident , left_location_id) } HfPlusNode :: Difference (..) | HfPlusNode :: AntiJoin (..) =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HfPlusNode :: Difference (..)) { parse_quote ! (difference_multiset) } <span class="kw">else </span>{ parse_quote ! (anti_join_multiset) } ; <span class="kw">let </span>(HfPlusNode :: Difference (left , right) | HfPlusNode :: AntiJoin (left , right)) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(right , right_was_persist) = <span class="kw">if let </span>HfPlusNode :: Persist (right) = right . as_ref () { (right , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (right , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(left_ident , left_location_id) = left . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id) = right . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"difference / anti join inputs must be in the same location"</span>) ; <span class="kw">let </span>stream_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>stream_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, stream_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; <span class="kw">if </span>right_was_persist { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'static </span>&gt; () ; }) ; } <span class="kw">else </span>{ builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; } builder . add_statement (parse_quote ! { # left_ident -&gt; [pos] # stream_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [neg] # stream_ident ; }) ; (stream_ident , left_location_id) } HfPlusNode :: Map { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>map_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>map_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, map_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # map_ident = # input_ident -&gt; map (# f) ; }) ; (map_ident , input_location_id) } HfPlusNode :: FlatMap { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>flat_map_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>flat_map_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, flat_map_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # flat_map_ident = # input_ident -&gt; flat_map (# f) ; }) ; (flat_map_ident , input_location_id) } HfPlusNode :: Filter { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>filter_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>filter_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, filter_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # filter_ident = # input_ident -&gt; filter (# f) ; }) ; (filter_ident , input_location_id) } HfPlusNode :: FilterMap { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>filter_map_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>filter_map_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, filter_map_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # filter_map_ident = # input_ident -&gt; filter_map (# f) ; }) ; (filter_map_ident , input_location_id) } HfPlusNode :: Sort (input) =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>sort_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>sort_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, sort_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # sort_ident = # input_ident -&gt; sort () ; }) ; (sort_ident , input_location_id) } HfPlusNode :: DeferTick (input) =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>defer_tick_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>defer_tick_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, defer_tick_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # defer_tick_ident = # input_ident -&gt; defer_tick_lazy () ; }) ; (defer_tick_ident , input_location_id) } HfPlusNode :: Enumerate (input) =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>enumerate_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>enumerate_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, enumerate_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # enumerate_ident = # input_ident -&gt; enumerate () ; }) ; (enumerate_ident , input_location_id) } HfPlusNode :: Inspect { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>inspect_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>inspect_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, inspect_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # inspect_ident = # input_ident -&gt; inspect (# f) ; }) ; (inspect_ident , input_location_id) } HfPlusNode :: Unique (input) =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>unique_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>unique_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, unique_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # unique_ident = # input_ident -&gt; unique ::&lt;<span class="lifetime">'tick </span>&gt; () ; }) ; (unique_ident , input_location_id) } HfPlusNode :: Fold { .. } | HfPlusNode :: FoldKeyed { .. } =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HfPlusNode :: Fold { .. }) { parse_quote ! (fold) } <span class="kw">else </span>{ parse_quote ! (fold_keyed) } ; <span class="kw">let </span>(HfPlusNode :: Fold { init , acc , input } | HfPlusNode :: FoldKeyed { init , acc , input }) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(input , input_was_persist) = <span class="kw">if let </span>HfPlusNode :: Persist (input) = input . as_ref () { (input , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (input , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>reduce_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>fold_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, reduce_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; <span class="kw">if </span>input_was_persist { builder . add_statement (parse_quote ! { # fold_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'static </span>&gt; (# init , # acc) ; }) ; } <span class="kw">else </span>{ builder . add_statement (parse_quote ! { # fold_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'tick </span>&gt; (# init , # acc) ; }) ; } (fold_ident , input_location_id) } HfPlusNode :: Reduce { .. } | HfPlusNode :: ReduceKeyed { .. } =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HfPlusNode :: Reduce { .. }) { parse_quote ! (reduce) } <span class="kw">else </span>{ parse_quote ! (reduce_keyed) } ; <span class="kw">let </span>(HfPlusNode :: Reduce { f , input } | HfPlusNode :: ReduceKeyed { f , input }) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(input , input_was_persist) = <span class="kw">if let </span>HfPlusNode :: Persist (input) = input . as_ref () { (input , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (input , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>reduce_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>reduce_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, reduce_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; <span class="kw">if </span>input_was_persist { builder . add_statement (parse_quote ! { # reduce_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'static </span>&gt; (# f) ; }) ; } <span class="kw">else </span>{ builder . add_statement (parse_quote ! { # reduce_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'tick </span>&gt; (# f) ; }) ; } (reduce_ident , input_location_id) } HfPlusNode :: Network { from_location : <span class="kw">_ </span>, from_key : <span class="kw">_ </span>, to_location , to_key : <span class="kw">_ </span>, serialize_pipeline , instantiate_fn , deserialize_pipeline , input , } =&gt; { <span class="kw">let </span>(sink_expr , source_expr , _connect_fn) = <span class="kw">match </span>instantiate_fn { DebugInstantiate :: Building () =&gt; { panic ! (<span class="string">"Expected the network to be finalized"</span>) } DebugInstantiate :: Finalized (sink , source , connect_fn) =&gt; { (sink , source , connect_fn) } } ; <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>sender_builder = graph_builders . entry (input_location_id) . or_default () ; <span class="kw">if let </span><span class="prelude-val">Some </span>(serialize_pipeline) = serialize_pipeline { sender_builder . add_statement (parse_quote ! { # input_ident -&gt; # serialize_pipeline -&gt; dest_sink (# sink_expr) ; }) ; } <span class="kw">else </span>{ sender_builder . add_statement (parse_quote ! { # input_ident -&gt; dest_sink (# sink_expr) ; }) ; } <span class="kw">let </span>to_id = <span class="kw">match </span>to_location { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , LocationId :: ExternalProcess (id) =&gt; id , } ; <span class="kw">let </span>receiver_builder = graph_builders . entry (* to_id) . or_default () ; <span class="kw">let </span>receiver_stream_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>receiver_stream_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, receiver_stream_id) , Span :: call_site ()) ; <span class="kw">if let </span><span class="prelude-val">Some </span>(deserialize_pipeline) = deserialize_pipeline { receiver_builder . add_statement (parse_quote ! { # receiver_stream_ident = source_stream (# source_expr) -&gt; # deserialize_pipeline ; }) ; } <span class="kw">else </span>{ receiver_builder . add_statement (parse_quote ! { # receiver_stream_ident = source_stream (# source_expr) ; }) ; } (receiver_stream_ident , * to_id) } } } } # [expect (clippy :: too_many_arguments , reason = <span class="string">"networking internals"</span>)] <span class="kw">pub fn </span>instantiate_network &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; + <span class="lifetime">'a </span>&gt; (from_location : &amp; <span class="kw-2">mut </span>LocationId , from_key : <span class="prelude-ty">Option </span>&lt; usize &gt; , to_location : &amp; <span class="kw-2">mut </span>LocationId , to_key : <span class="prelude-ty">Option </span>&lt; usize &gt; , nodes : &amp; HashMap &lt; usize , D :: Process &gt; , clusters : &amp; HashMap &lt; usize , D :: Cluster &gt; , externals : &amp; HashMap &lt; usize , D :: ExternalProcess &gt; , compile_env : &amp; D :: CompileEnv ,) -&gt; (syn :: Expr , syn :: Expr , Box &lt; <span class="kw">dyn </span>FnOnce () &gt;) { <span class="kw">let </span>((sink , source) , connect_fn) = <span class="kw">match </span>(from_location , to_location) { (LocationId :: Process (from) , LocationId :: Process (to)) =&gt; { <span class="kw">let </span>from_node = nodes . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A process used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = nodes . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A process used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_process_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_process_port (&amp; to_node) ; (D :: o2o_sink_source (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) , D :: o2o_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) ,) } (LocationId :: Process (from) , LocationId :: Cluster (to)) =&gt; { <span class="kw">let </span>from_node = nodes . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A process used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = clusters . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A cluster used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_process_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_cluster_port (&amp; to_node) ; (D :: o2m_sink_source (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) , D :: o2m_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) ,) } (LocationId :: Cluster (from) , LocationId :: Process (to)) =&gt; { <span class="kw">let </span>from_node = clusters . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A cluster used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = nodes . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A process used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_cluster_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_process_port (&amp; to_node) ; (D :: m2o_sink_source (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) , D :: m2o_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) ,) } (LocationId :: Cluster (from) , LocationId :: Cluster (to)) =&gt; { <span class="kw">let </span>from_node = clusters . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A cluster used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = clusters . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A cluster used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_cluster_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_cluster_port (&amp; to_node) ; (D :: m2m_sink_source (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) , D :: m2m_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) ,) } (LocationId :: ExternalProcess (from) , LocationId :: Process (to)) =&gt; { <span class="kw">let </span>from_node = externals . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A external used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = nodes . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A process used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_external_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_process_port (&amp; to_node) ; from_node . register (from_key . unwrap () , sink_port . clone ()) ; ((parse_quote ! (DUMMY) , D :: e2o_source (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) ,) , D :: e2o_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) ,) } (LocationId :: ExternalProcess (_from) , LocationId :: Cluster (_to)) =&gt; { todo ! (<span class="string">"NYI"</span>) } (LocationId :: ExternalProcess (<span class="kw">_</span>) , LocationId :: ExternalProcess (<span class="kw">_</span>)) =&gt; { panic ! (<span class="string">"Cannot send from external to external"</span>) } (LocationId :: Process (from) , LocationId :: ExternalProcess (to)) =&gt; { <span class="kw">let </span>from_node = nodes . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A process used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = externals . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A external used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_process_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_external_port (&amp; to_node) ; to_node . register (to_key . unwrap () , source_port . clone ()) ; ((D :: o2e_sink (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) , parse_quote ! (DUMMY) ,) , D :: o2e_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) ,) } (LocationId :: Cluster (_from) , LocationId :: ExternalProcess (_to)) =&gt; { todo ! (<span class="string">"NYI"</span>) } } ; (sink , source , connect_fn) } } <span class="kw">pub mod </span>persist_pullup { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: collections :: HashSet ; <span class="kw">pub use crate </span>:: ir :: * ; <span class="kw">pub fn </span>persist_pullup_node (node : &amp; <span class="kw-2">mut </span>HfPlusNode , persist_pulled_tees : &amp; <span class="kw-2">mut </span>HashSet &lt; * <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; &gt; ,) { * node = <span class="kw">match </span>std :: mem :: replace (node , HfPlusNode :: Placeholder) { HfPlusNode :: Unpersist (<span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">box </span>behind_persist)) =&gt; behind_persist , HfPlusNode :: Delta (<span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">box </span>behind_persist)) =&gt; behind_persist , HfPlusNode :: Tee { inner } =&gt; { <span class="kw">if </span>persist_pulled_tees . contains (&amp; (inner . <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt;)) { HfPlusNode :: Persist (Box :: new (HfPlusNode :: Tee { inner : TeeNode (inner . <span class="number">0 </span>. clone ()) , })) } <span class="kw">else if </span>matches ! (* inner . <span class="number">0 </span>. borrow () , HfPlusNode :: Persist (<span class="kw">_</span>)) { persist_pulled_tees . insert (inner . <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt;) ; <span class="kw">if let </span>HfPlusNode :: Persist (<span class="kw">box </span>behind_persist) = inner . <span class="number">0 </span>. replace (HfPlusNode :: Placeholder) { * inner . <span class="number">0 </span>. borrow_mut () = behind_persist ; } <span class="kw">else </span>{ unreachable ! () } HfPlusNode :: Persist (Box :: new (HfPlusNode :: Tee { inner : TeeNode (inner . <span class="number">0 </span>. clone ()) , })) } <span class="kw">else </span>{ HfPlusNode :: Tee { inner } } } HfPlusNode :: Map { f , input : <span class="kw">box </span>HfPlusNode :: Persist (behind_persist) , } =&gt; HfPlusNode :: Persist (Box :: new (HfPlusNode :: Map { f , input : behind_persist , })) , HfPlusNode :: FlatMap { f , input : <span class="kw">box </span>HfPlusNode :: Persist (behind_persist) , } =&gt; HfPlusNode :: Persist (Box :: new (HfPlusNode :: FlatMap { f , input : behind_persist , })) , HfPlusNode :: Filter { f , input : <span class="kw">box </span>HfPlusNode :: Persist (behind_persist) , } =&gt; HfPlusNode :: Persist (Box :: new (HfPlusNode :: Filter { f , input : behind_persist , })) , HfPlusNode :: Network { from_location , from_key , to_location , to_key , serialize_pipeline , instantiate_fn , deserialize_pipeline , input : <span class="kw">box </span>HfPlusNode :: Persist (behind_persist) , .. } =&gt; HfPlusNode :: Persist (Box :: new (HfPlusNode :: Network { from_location , from_key , to_location , to_key , serialize_pipeline , instantiate_fn , deserialize_pipeline , input : behind_persist , })) , HfPlusNode :: Union (<span class="kw">box </span>HfPlusNode :: Persist (left) , <span class="kw">box </span>HfPlusNode :: Persist (right)) =&gt; { HfPlusNode :: Persist (Box :: new (HfPlusNode :: Union (left , right))) } HfPlusNode :: CrossProduct (<span class="kw">box </span>HfPlusNode :: Persist (left) , <span class="kw">box </span>HfPlusNode :: Persist (right)) =&gt; { HfPlusNode :: Persist (Box :: new (HfPlusNode :: Delta (Box :: new (HfPlusNode :: CrossProduct (Box :: new (HfPlusNode :: Persist (left)) , Box :: new (HfPlusNode :: Persist (right)) ,) ,)))) } HfPlusNode :: Join (<span class="kw">box </span>HfPlusNode :: Persist (left) , <span class="kw">box </span>HfPlusNode :: Persist (right)) =&gt; { HfPlusNode :: Persist (Box :: new (HfPlusNode :: Delta (Box :: new (HfPlusNode :: Join (Box :: new (HfPlusNode :: Persist (left)) , Box :: new (HfPlusNode :: Persist (right)) ,))))) } HfPlusNode :: Unique (<span class="kw">box </span>HfPlusNode :: Persist (inner)) =&gt; { HfPlusNode :: Persist (Box :: new (HfPlusNode :: Delta (Box :: new (HfPlusNode :: Unique (Box :: new (HfPlusNode :: Persist (inner)) ,))))) } node =&gt; node , } ; } <span class="kw">pub fn </span>persist_pullup (ir : Vec &lt; HfPlusLeaf &gt;) -&gt; Vec &lt; HfPlusLeaf &gt; { <span class="kw">let </span><span class="kw-2">mut </span>seen_tees = Default :: default () ; <span class="kw">let </span><span class="kw-2">mut </span>persist_pulled_tees = Default :: default () ; ir . into_iter () . map (| l | { l . transform_children (| n , s | n . transform_bottom_up (persist_pullup_node , s , &amp; <span class="kw-2">mut </span>persist_pulled_tees) , &amp; <span class="kw-2">mut </span>seen_tees ,) }) . collect () } # [cfg (stageleft_macro)] <span class="kw">pub mod </span>tests { <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub use crate </span>:: deploy :: MultiGraph ; <span class="kw">pub use crate </span>:: location :: Location ; # [test] <span class="kw">pub fn </span>persist_pullup_through_map () { <span class="kw">let </span>flow = <span class="kw">crate </span>:: builder :: FlowBuilder :: new () ; <span class="kw">let </span>process = flow . process :: &lt; () &gt; () ; process . source_iter (q ! (<span class="number">0 </span>.. <span class="number">10</span>)) . map (q ! (| v | v + <span class="number">1</span>)) . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; <span class="kw">let </span>built = flow . finalize () ; insta :: assert_debug_snapshot ! (built . ir ()) ; <span class="kw">let </span>optimized = built . optimize_with (<span class="kw">super </span>:: persist_pullup) ; insta :: assert_debug_snapshot ! (optimized . ir ()) ; <span class="kw">for </span>(id , graph) <span class="kw">in </span>optimized . compile_no_network :: &lt; MultiGraph &gt; () . hydroflow_ir () { insta :: with_settings ! ({ snapshot_suffix =&gt; format ! (<span class="string">"surface_graph_{id}"</span>) } , { insta :: assert_snapshot ! (graph . surface_syntax_string ()) ; }) ; } } # [test] <span class="kw">pub fn </span>persist_pullup_behind_tee () { <span class="kw">let </span>flow = <span class="kw">crate </span>:: builder :: FlowBuilder :: new () ; <span class="kw">let </span>process = flow . process :: &lt; () &gt; () ; <span class="kw">let </span>before_tee = process . source_iter (q ! (<span class="number">0 </span>.. <span class="number">10</span>)) . tick_batch () . persist () ; before_tee . clone () . map (q ! (| v | v + <span class="number">1</span>)) . all_ticks () . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; before_tee . clone () . map (q ! (| v | v + <span class="number">1</span>)) . all_ticks () . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; <span class="kw">let </span>built = flow . finalize () ; insta :: assert_debug_snapshot ! (built . ir ()) ; <span class="kw">let </span>optimized = built . optimize_with (<span class="kw">super </span>:: persist_pullup) ; insta :: assert_debug_snapshot ! (optimized . ir ()) ; <span class="kw">for </span>(id , graph) <span class="kw">in </span>optimized . compile_no_network :: &lt; MultiGraph &gt; () . hydroflow_ir () { insta :: with_settings ! ({ snapshot_suffix =&gt; format ! (<span class="string">"surface_graph_{id}"</span>) } , { insta :: assert_snapshot ! (graph . surface_syntax_string ()) ; }) ; } } } } <span class="kw">pub mod </span>profiler { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>hydroflow :: futures :: channel :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub use crate </span>:: ir :: * ; <span class="kw">pub use crate </span>:: { profiler <span class="kw">as </span>myself , RuntimeContext } ; <span class="kw">pub fn </span>increment_counter (count : &amp; <span class="kw-2">mut </span>u64) { * count += <span class="number">1 </span>; } <span class="kw">pub fn </span>quoted_any_fn &lt; <span class="lifetime">'a </span>, F : Fn (&amp; usize) + <span class="lifetime">'a </span>, Q : IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; &gt; (q : Q) -&gt; Q { q } # [doc = <span class="string">" Add a profiling node before each node to count the cardinality of its input"</span>] <span class="kw">pub fn </span>add_profiling_node &lt; <span class="lifetime">'a </span>&gt; (node : &amp; <span class="kw-2">mut </span>HfPlusNode , _context : RuntimeContext &lt; <span class="lifetime">'a </span>&gt; , counters : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; Vec &lt; u64 &gt; &gt; &gt; , counter_queue : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; UnboundedSender &lt; (usize , u64) &gt; &gt; &gt; , id : &amp; <span class="kw-2">mut </span>u32 , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees ,) { <span class="kw">let </span>my_id = * id ; * id += <span class="number">1 </span>; node . transform_children (| node , seen_tees | { add_profiling_node (node , _context , counters , counter_queue , id , seen_tees) } , seen_tees ,) ; <span class="kw">let </span>orig_node = std :: mem :: replace (node , HfPlusNode :: Placeholder) ; * node = HfPlusNode :: Inspect { f : quoted_any_fn (q ! ({ counter_queue . borrow () . unbounded_send ((my_id <span class="kw">as </span>usize , counters . borrow () [my_id <span class="kw">as </span>usize])) . unwrap () ; counters . borrow_mut () [my_id <span class="kw">as </span>usize] = <span class="number">0 </span>; <span class="kw">move </span>| <span class="kw">_ </span>| { myself :: increment_counter (&amp; <span class="kw-2">mut </span>counters . borrow_mut () [my_id <span class="kw">as </span>usize]) ; } })) . splice_untyped () . into () , input : Box :: new (orig_node) , } } # [doc = <span class="string">" Count the cardinality of each input and periodically output to a file"</span>] <span class="kw">pub fn </span>profiling &lt; <span class="lifetime">'a </span>&gt; (ir : Vec &lt; HfPlusLeaf &gt; , context : RuntimeContext &lt; <span class="lifetime">'a </span>&gt; , counters : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; Vec &lt; u64 &gt; &gt; &gt; , counter_queue : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; UnboundedSender &lt; (usize , u64) &gt; &gt; &gt; ,) -&gt; Vec &lt; HfPlusLeaf &gt; { <span class="kw">let </span><span class="kw-2">mut </span>id = <span class="number">0 </span>; <span class="kw">let </span><span class="kw-2">mut </span>seen_tees = Default :: default () ; ir . into_iter () . map (| l | { l . transform_children (| node , seen_tees | { add_profiling_node (node , context , counters , counter_queue , &amp; <span class="kw-2">mut </span>id , seen_tees) } , &amp; <span class="kw-2">mut </span>seen_tees ,) }) . collect () } # [cfg (stageleft_macro)] <span class="kw">pub mod </span>tests { <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub use crate </span>:: deploy :: MultiGraph ; <span class="kw">pub use crate </span>:: location :: Location ; # [test] <span class="kw">pub fn </span>profiler_wrapping_all_operators () { <span class="kw">let </span>flow = <span class="kw">crate </span>:: builder :: FlowBuilder :: new () ; <span class="kw">let </span>process = flow . process :: &lt; () &gt; () ; process . source_iter (q ! (<span class="number">0 </span>.. <span class="number">10</span>)) . map (q ! (| v | v + <span class="number">1</span>)) . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; <span class="kw">let </span>runtime_context = flow . runtime_context () ; <span class="kw">let </span>built = flow . finalize () ; insta :: assert_debug_snapshot ! (&amp; built . ir ()) ; <span class="kw">let </span>counters = RuntimeData :: new (<span class="string">"Fake"</span>) ; <span class="kw">let </span>counter_queue = RuntimeData :: new (<span class="string">"Fake"</span>) ; <span class="kw">let </span>pushed_down = built . with_default_optimize () . optimize_with (| ir | <span class="kw">super </span>:: profiling (ir , runtime_context , counters , counter_queue)) ; insta :: assert_debug_snapshot ! (&amp; pushed_down . ir ()) ; <span class="kw">let _ </span>= pushed_down . compile_no_network :: &lt; MultiGraph &gt; () ; } } } <span class="kw">pub mod </span>properties { <span class="kw">pub use </span>std :: collections :: HashSet ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub use crate </span>:: ir :: { HfPlusLeaf , HfPlusNode , SeenTees } ; <span class="kw">pub use crate </span>:: properties :: PropertyDatabase ; # [doc = <span class="string">" Allows us to convert the hydroflow datatype for folds to a binary operation for the algebra"</span>] # [doc = <span class="string">" property tests."</span>] # [allow (clippy :: allow_attributes , dead_code , reason = <span class="string">"staged programming"</span>)] <span class="kw">pub fn </span>convert_hf_to_binary &lt; I , A : Default , F : Fn (&amp; <span class="kw-2">mut </span>A , I) &gt; (f : F) -&gt; <span class="kw">impl </span>Fn (I , I) -&gt; A { <span class="kw">move </span>| a , b | { <span class="kw">let </span><span class="kw-2">mut </span>acc = Default :: default () ; f (&amp; <span class="kw-2">mut </span>acc , a) ; f (&amp; <span class="kw-2">mut </span>acc , b) ; acc } } # [cfg (stageleft_macro)] <span class="kw">impl </span>PropertyDatabase { # [doc = <span class="string">" Tags the expression as commutative."</span>] <span class="kw">pub fn </span>add_commutative_tag &lt; <span class="lifetime">'a </span>, I , A , F : Fn (&amp; <span class="kw-2">mut </span>A , I) , Q : Quoted &lt; <span class="lifetime">'a </span>, F &gt; + Clone &gt; (&amp; <span class="kw-2">mut </span><span class="self">self </span>, expr : Q ,) -&gt; Q { <span class="kw">let </span>expr_clone = expr . clone () ; <span class="self">self </span>. commutative . insert (expr_clone . splice_untyped ()) ; expr } <span class="kw">pub fn </span>is_tagged_commutative (&amp; <span class="self">self </span>, expr : &amp; syn :: Expr) -&gt; bool { <span class="self">self </span>. commutative . contains (expr) } } <span class="kw">pub fn </span>properties_optimize_node (node : &amp; <span class="kw-2">mut </span>HfPlusNode , db : &amp; PropertyDatabase , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees ,) { node . transform_children (| node , seen_tees | properties_optimize_node (node , db , seen_tees) , seen_tees ,) ; <span class="kw">match </span>node { HfPlusNode :: ReduceKeyed { f , .. } <span class="kw">if </span>db . is_tagged_commutative (&amp; f . <span class="number">0</span>) =&gt; { dbg ! (<span class="string">"IDENTIFIED COMMUTATIVE OPTIMIZATION for {:?}" </span>, &amp; f) ; } <span class="kw">_ </span>=&gt; { } } } <span class="kw">pub fn </span>properties_optimize (ir : Vec &lt; HfPlusLeaf &gt; , db : &amp; PropertyDatabase) -&gt; Vec &lt; HfPlusLeaf &gt; { <span class="kw">let </span><span class="kw-2">mut </span>seen_tees = Default :: default () ; ir . into_iter () . map (| l | { l . transform_children (| node , seen_tees | properties_optimize_node (node , db , seen_tees) , &amp; <span class="kw-2">mut </span>seen_tees ,) }) . collect () } # [cfg (stageleft_macro)] <span class="kw">pub mod </span>tests { <span class="kw">pub use super </span>:: * ; <span class="kw">pub use crate </span>:: deploy :: SingleProcessGraph ; <span class="kw">pub use crate </span>:: location :: Location ; <span class="kw">pub use crate </span>:: FlowBuilder ; # [test] <span class="kw">pub fn </span>test_property_database () { <span class="kw">let </span><span class="kw-2">mut </span>db = PropertyDatabase :: default () ; assert ! (! db . is_tagged_commutative (&amp; (q ! (| a : &amp; <span class="kw-2">mut </span>i32 , b : i32 | * a += b) . splice_untyped ()))) ; <span class="kw">let _ </span>= db . add_commutative_tag (q ! (| a : &amp; <span class="kw-2">mut </span>i32 , b : i32 | * a += b)) ; assert ! (db . is_tagged_commutative (&amp; (q ! (| a : &amp; <span class="kw-2">mut </span>i32 , b : i32 | * a += b) . splice_untyped ()))) ; } # [test] <span class="kw">pub fn </span>test_property_optimized () { <span class="kw">let </span>flow = FlowBuilder :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>database = PropertyDatabase :: default () ; <span class="kw">let </span>process = flow . process :: &lt; () &gt; () ; <span class="kw">let </span>counter_func = q ! (| count : &amp; <span class="kw-2">mut </span>i32 , <span class="kw">_ </span>| * count += <span class="number">1</span>) ; <span class="kw">let _ </span>= database . add_commutative_tag (counter_func) ; process . source_iter (q ! (vec ! [])) . map (q ! (| string : String | (string , ()))) . tick_batch () . fold_keyed (q ! (|| <span class="number">0</span>) , counter_func) . all_ticks () . for_each (q ! (| (string , count) | println ! (<span class="string">"{}: {}" </span>, string , count))) ; <span class="kw">let </span>built = flow . finalize () . optimize_with (| ir | properties_optimize (ir , &amp; database)) . with_default_optimize () ; insta :: assert_debug_snapshot ! (built . ir ()) ; <span class="kw">let _ </span>= built . compile_no_network :: &lt; SingleProcessGraph &gt; () ; } } } <span class="kw">pub mod </span>staging_util { <span class="kw">pub use </span>proc_macro2 :: { Span , TokenStream } ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub fn </span>get_this_crate () -&gt; TokenStream { <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">"hydroflow_plus"</span>) . expect (<span class="string">"hydroflow_plus should be present in `Cargo.toml`"</span>) ; <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydroflow_plus } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , Span :: call_site ()) ; quote ! { # ident } } } } } <span class="kw">pub use crate </span>:: RuntimeContext ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Copy <span class="kw">for </span>RuntimeContext &lt; <span class="lifetime">'_ </span>&gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FreeVariable &lt; &amp; <span class="lifetime">'a </span>Context &gt; <span class="kw">for </span>RuntimeContext &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>to_tokens (<span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(quote ! (&amp; context))) } } <span class="kw">pub use crate </span>:: HfCompiled ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, ID &gt; HfCompiled &lt; <span class="lifetime">'a </span>, ID &gt; { <span class="kw">pub fn </span>hydroflow_ir (&amp; <span class="self">self</span>) -&gt; &amp; BTreeMap &lt; usize , HydroflowGraph &gt; { &amp; <span class="self">self </span>. hydroflow_ir } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; HfCompiled &lt; <span class="lifetime">'a </span>, usize &gt; { <span class="kw">pub fn </span>with_dynamic_id (<span class="self">self </span>, id : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, usize &gt;) -&gt; HfBuiltWithId &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">"hydroflow_plus"</span>) . expect (<span class="string">"hydroflow_plus should be present in `Cargo.toml`"</span>) ; <span class="kw">let </span>root = <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydroflow_plus } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , proc_macro2 :: Span :: call_site ()) ; quote ! { # ident } } } ; <span class="kw">let </span><span class="kw-2">mut </span>conditioned_tokens = <span class="prelude-val">None </span>; <span class="kw">for </span>(subgraph_id , flat_graph) <span class="kw">in </span><span class="self">self </span>. hydroflow_ir { <span class="kw">let </span>partitioned_graph = partition_graph (flat_graph) . expect (<span class="string">"Failed to partition (cycle detected)."</span>) ; <span class="kw">let </span><span class="kw-2">mut </span>diagnostics = Vec :: new () ; <span class="kw">let </span>tokens = partitioned_graph . as_code (&amp; root , <span class="bool-val">true </span>, quote :: quote ! () , &amp; <span class="kw-2">mut </span>diagnostics) ; <span class="kw">let </span>my_extra_stmts = <span class="self">self </span>. extra_stmts . get (&amp; subgraph_id) . cloned () . unwrap_or_default () ; <span class="kw">if let </span><span class="prelude-val">Some </span>(conditioned_tokens) = conditioned_tokens . as_mut () { * conditioned_tokens = syn :: parse_quote ! { # conditioned_tokens <span class="kw">else if </span>__given_id == # subgraph_id { # (# my_extra_stmts) * # tokens } } ; } <span class="kw">else </span>{ conditioned_tokens = <span class="prelude-val">Some </span>(syn :: parse_quote ! { <span class="kw">if </span>__given_id == # subgraph_id { # (# my_extra_stmts) * # tokens } }) ; } } <span class="kw">let </span>conditioned_tokens : TokenStream = conditioned_tokens . unwrap () ; <span class="kw">let </span>id = id . splice_untyped () ; HfBuiltWithId { tokens : syn :: parse_quote ! ({ <span class="kw">let </span>__given_id = # id ; # conditioned_tokens <span class="kw">else </span>{ panic ! (<span class="string">"Invalid node id: {}" </span>, __given_id) ; } }) , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; <span class="kw">for </span>HfCompiled &lt; <span class="lifetime">'a </span>, () &gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FreeVariable &lt; Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; <span class="kw">for </span>HfCompiled &lt; <span class="lifetime">'a </span>, () &gt; { <span class="kw">fn </span>to_tokens (<span class="kw-2">mut </span><span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">"hydroflow_plus"</span>) . expect (<span class="string">"hydroflow_plus should be present in `Cargo.toml`"</span>) ; <span class="kw">let </span>root = <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydroflow_plus } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , proc_macro2 :: Span :: call_site ()) ; quote ! { # ident } } } ; <span class="kw">if </span><span class="self">self </span>. hydroflow_ir . len () != <span class="number">1 </span>{ panic ! (<span class="string">"Expected exactly one subgraph in the Hydroflow IR"</span>) ; } <span class="kw">let </span>flat_graph = <span class="self">self </span>. hydroflow_ir . remove (&amp; <span class="number">0</span>) . unwrap () ; <span class="kw">let </span>partitioned_graph = partition_graph (flat_graph) . expect (<span class="string">"Failed to partition (cycle detected)."</span>) ; <span class="kw">let </span><span class="kw-2">mut </span>diagnostics = Vec :: new () ; <span class="kw">let </span>tokens = partitioned_graph . as_code (&amp; root , <span class="bool-val">true </span>, quote :: quote ! () , &amp; <span class="kw-2">mut </span>diagnostics) ; (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(tokens)) } } <span class="kw">pub use crate </span>:: HfBuiltWithId ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; <span class="kw">for </span>HfBuiltWithId &lt; <span class="lifetime">'a </span>&gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FreeVariable &lt; Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; <span class="kw">for </span>HfBuiltWithId &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>to_tokens (<span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(<span class="self">self </span>. tokens)) } } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { # [ctor :: ctor] <span class="kw">fn </span>init () { <span class="kw">crate </span>:: deploy :: init_test () ; } }</code></pre></div></section></main></body></html>